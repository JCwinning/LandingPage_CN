---
title: "åŸºäº RAG çš„å¨å£«å¿Œå“é‰´ç¬”è®°"
author: "Tony D"
date: "2025-11-05"
categories: [AI, API, tutorial]
image: "images/0.png"

format:
  html:
    code-fold: true
    code-tools: true
    code-copy: true

execute:
  eval: false
  warning: false

  
  
---


# é¡¹ç›®æ¦‚è§ˆ

å¨å£«å¿Œå“é‰´åº”ç”¨æ˜¯ä¸€æ¬¾å…ˆè¿›çš„ AI é©±åŠ¨ Web åº”ç”¨ç¨‹åºï¼Œå¯ç”Ÿæˆè¯¦ç»†ã€ä¸“ä¸šçš„å¨å£«å¿Œå“é‰´ç¬”è®°å’Œå»ºè®®ã€‚è¯¥ç³»ç»Ÿçš„ç‰¹åˆ«ä¹‹å¤„åœ¨äºå…¶é‡‡ç”¨äº†å¤š Agent æ¶æ„ï¼Œå¹¶é…å¤‡äº†ä¸“é—¨çš„ AI äººæ ¼ï¼Œæ¯ä¸ªäººæ ¼éƒ½ç»è¿‡äº†ä¸åŒå¨å£«å¿Œè¯„è®ºæºå’Œè¯­è¨€é£æ ¼çš„è®­ç»ƒã€‚

åœ¨çº¿æ¼”ç¤º (Modelscope): [https://modelscope.cn/studios/ttflying/whisky_AI_tasting](https://modelscope.cn/studios/ttflying/whisky_AI_tasting)

åœ¨çº¿æ¼”ç¤º (Shinyapp): [https://jcflyingco.shinyapps.io/ai-whisky-tasting/](https://jcflyingco.shinyapps.io/ai-whisky-tasting)

Github: [https://github.com/JCwinning/whisky_tasting](https://github.com/JCwinning/whisky_tasting)



::: {.panel-tabset}




## AI å“é‰´è¯
![](images/0.png){width="100%"}


## AI æ¨è

![](images/1.png){width="100%"}


::: 


## æ ¸å¿ƒæ¶æ„

### å¤š Agent AI ç³»ç»Ÿ

è¯¥åº”ç”¨åŒ…å«ä¸‰ä¸ªä¸“é—¨çš„ AI Agentï¼Œæ¯ä¸ª Agent éƒ½æœ‰ç‹¬ç‰¹çš„ç‰¹å¾å’Œæ•°æ®æºï¼š

1. **DrunkTony (dt)** - ä¸­æ–‡ Agentï¼Œä¸“æ³¨äºä¸­æ–‡å¨å£«å¿Œè¯„è®ºã€‚
2. **WhiskyFunny (wf)** - è‹±æ–‡ Agentï¼Œæ•°æ®æºè‡ª whiskyfun.comã€‚
3. **WhiskyNotebook (wn)** - è‹±æ–‡ Agentï¼Œæ•°æ®æºè‡ª whiskynotes.beã€‚

### æŠ€æœ¯æ ˆ
- **ä¸»è¦è¯­è¨€**: Python 3.13+
- **Web æ¡†æ¶**: Streamlit (ä¸»é€‰) + Shiny for Python (å¤‡é€‰)
- **æ•°æ®åº“**: DuckDB (376MBï¼Œé’ˆå¯¹å‘é‡æ“ä½œè¿›è¡Œäº†ä¼˜åŒ–)
- **AI/ML**: OpenAI API, å‘é‡åµŒå…¥ (Vector embeddings), RAG ç³»ç»Ÿ
- **æ•°æ®æº**: ä½¿ç”¨ BeautifulSoup4 è¿›è¡Œç½‘é¡µæŠ“å–

## æ•°æ®åº“æ¶æ„

### æ•°æ®æ¨¡å¼ä¸æ¥æº

ç³»ç»Ÿä½¿ç”¨ DuckDB ä½œä¸ºä¸»æ•°æ®åº“ï¼Œå› å…¶åœ¨å‘é‡æ“ä½œæ–¹é¢è¡¨ç°å“è¶Šï¼š

```sql
-- æ•°æ®åº“ç»“æ„
CREATE TABLE drinktony_embed (
    full TEXT,
    bottle_embedding FLOAT[1024]  -- 1024 ç»´å‘é‡
);

CREATE TABLE whiskyfun_embed (
    full TEXT,
    bottle_embedding FLOAT[1024]
);

CREATE TABLE whiskynote_embed (
    full TEXT,
    bottle_embedding FLOAT[1024]
);
```

### æ•°æ®é‡‡é›†æµç¨‹

```{python}
# get_data_dt.py ä¸­çš„ç½‘é¡µæŠ“å–ç¤ºä¾‹
def scrape_drinktony_reviews():
    """ä» drinktony.netlify.app æŠ“å–ä¸­æ–‡å¨å£«å¿Œè¯„è®º"""
    url = "https://drinktony.netlify.app/"
    response = requests.get(url)
    soup = BeautifulSoup(response.content, "html.parser")

    # æŸ¥æ‰¾æ‰€æœ‰è¯„è®ºé“¾æ¥
    post_links = [urljoin(url, a.get("href"))
                 for a in soup.select("a.quarto-grid-link")]

    all_reviews = []
    for post_url in post_links:
        response = requests.get(post_url)
        soup = BeautifulSoup(response.content, "html.parser")

        # æå–è¯„è®ºç« èŠ‚
        review_sections = soup.select("section.level1")
        for section in review_sections:
            # è§£æå¨å£«å¿Œåç§°å’Œè¯„è®ºå†…å®¹
            whisky_name = extract_whisky_name(section)
            review_text = extract_review_text(section)
            all_reviews.append({
                'whisky': whisky_name,
                'review': review_text
            })

    return all_reviews
```

## AI/ML å®ç°

### å‘é‡åµŒå…¥æŠ€æœ¯

åº”ç”¨ä½¿ç”¨å°–ç«¯çš„åµŒå…¥æŠ€æœ¯å°†æ–‡æœ¬è½¬æ¢ä¸ºé«˜ç»´å‘é‡ï¼Œä»¥ä¾¿è¿›è¡Œè¯­ä¹‰ç›¸ä¼¼åº¦æœç´¢ã€‚

#### åµŒå…¥æ¨¡å‹è¯¦æƒ…

**æ¨¡å‹**: BAAI/bge-large-zh-v1.5
- **ç»´åº¦**: 1024
- **æœåŠ¡å•†**: SiliconFlow API
- **ç”¨é€”**: è·¨è¯­è¨€æ–‡æœ¬ç†è§£ï¼ˆåœ¨ä¸­è‹±æ–‡æ–¹é¢è¡¨ç°å‡å¾ˆå‡ºè‰²ï¼‰

#### ä¸ºä»€ä¹ˆé€‰æ‹© BGE-Large-ZH?

1. **è·¨è¯­è¨€èƒ½åŠ›**: åœ¨ç†è§£ä¸­è‹±æ–‡å¨å£«å¿Œä¸“ä¸šæœ¯è¯­æ–¹é¢è¡¨ç°ä¼˜å¼‚ã€‚
2. **é«˜æ€§èƒ½**: ä¸é€šç”¨åµŒå…¥æ¨¡å‹ç›¸æ¯”ï¼Œå…·å¤‡æ›´å‡ºè‰²çš„è¯­ä¹‰ç†è§£èƒ½åŠ›ã€‚
3. **é«˜æ•ˆå°ºå¯¸**: 1024 ç»´åº¦åœ¨æ€§èƒ½å’Œå­˜å‚¨æ•ˆç‡ä¹‹é—´è¾¾åˆ°äº†å¹³è¡¡ã€‚
4. **API è®¿é—®**: é€šè¿‡ SiliconFlow æä¾›ç¨³å®šçš„æœåŠ¡ã€‚

#### åµŒå…¥æµç¨‹

è¯¥åº”ç”¨ä½¿ç”¨ BGE-Large-ZH-v1.5 æ¨¡å‹ç”ŸæˆåµŒå…¥å‘é‡ï¼š

```{python}
def get_embedding(text: str, api_key: str):
    """ä½¿ç”¨ SiliconFlow API ç”Ÿæˆæ–‡æœ¬åµŒå…¥"""
    client = OpenAI(
        api_key=api_key,
        base_url="https://api.siliconflow.cn/v1"
    )
    response = client.embeddings.create(
        model="BAAI/bge-large-zh-v1.5",
        input=[text]
    )
    return np.array(response.data[0].embedding)

def cosine_similarity(v1, v2):
    """è®¡ç®—ä¸¤ä¸ªå‘é‡ä¹‹é—´çš„ä½™å¼¦ç›¸ä¼¼åº¦"""
    if v1 is None or v2 is None:
        return 0
    return np.dot(v1, v2) / (np.linalg.norm(v1) * np.linalg.norm(v2))
```

### RAG ç³»ç»Ÿæ¶æ„

æ£€ç´¢å¢å¼ºç”Ÿæˆ (RAG) ç³»ç»Ÿæ˜¯æ­¤åº”ç”¨çš„æ ¸å¿ƒåˆ›æ–°ã€‚è®©æˆ‘ä»¬è¯¦ç»†æ¢è®¨å…¶ç»„ä»¶ã€‚

### RAG å·¥ä½œæµ

æ£€ç´¢å¢å¼ºç”Ÿæˆè¿‡ç¨‹éµå¾ªä»¥ä¸‹æ­¥éª¤ï¼š

```mermaid
%%| fig-cap: "å¨å£«å¿Œå“é‰´çš„ RAG å·¥ä½œæµ"
flowchart TD
    A[ç”¨æˆ·è¾“å…¥<br/>å¨å£«å¿Œåç§°] --> B[ç”ŸæˆåµŒå…¥å‘é‡]
    B --> C[DuckDB ä¸­çš„<br/>å‘é‡ç›¸ä¼¼åº¦æœç´¢]
    C --> D[æ£€ç´¢å‰ 10 æ¡<br/>ç›¸ä¼¼è¯„è®º]
    D --> E[ä¸º LLM æ ¼å¼åŒ–ä¸Šä¸‹æ–‡]
    E --> F[ä¸» LLM<br/>ç”Ÿæˆå“é‰´ç¬”è®°]
    F --> G[å‰¯ LLM<br/>ç”Ÿæˆæ¨èå»ºè®®]
    G --> H[æ ¼å¼åŒ–å¹¶<br/>æ˜¾ç¤ºç»“æœ]

    C --> I[æ•°æ®åº“]
    I --> J[drinktony_embed<br/>1200 æ¡ä¸­æ–‡è¯„è®º]
    I --> K[whiskyfun_embed<br/>2 ä¸‡æ¡è‹±æ–‡è¯„è®º]
    I --> L[whiskynote_embed<br/>5000 æ¡è‹±æ–‡è¯„è®º]
```

### ç›¸ä¼¼åº¦æœç´¢å®ç°

```{python}
def find_similar_chunks(
    query_embedding,
    db_path,
    table_name,
    text_col,
    embedding_col,
    top_n=10,
):
    """ä½¿ç”¨ä½™å¼¦ç›¸ä¼¼åº¦åœ¨æ•°æ®åº“ä¸­æŸ¥æ‰¾æœ€ç›¸ä¼¼çš„æ–‡æœ¬å—"""
    try:
        with duckdb.connect(database=db_path, read_only=True) as con:
            df = con.execute(
                f'SELECT "{text_col}", "{embedding_col}" FROM "{table_name}"'
            ).fetchdf()

            # è®¡ç®—ç›¸ä¼¼åº¦
            similarities = []
            for _, row in df.iterrows():
                text = row[text_col]
                embedding = np.array(row[embedding_col])
                similarity = cosine_similarity(query_embedding, embedding)
                similarities.append((text, similarity))

            # æŒ‰ç›¸ä¼¼åº¦æ’åºå¹¶è¿”å›å‰ N æ¡
            similarities.sort(key=lambda x: x[1], reverse=True)
            return similarities[:top_n]

    except Exception as e:
        print(f"æœç´¢ç›¸ä¼¼å—æ—¶å‡ºé”™: {e}")
        return []
```

## ä¸“é—¨ Agent çš„å®ç°

### DrunkTony (ä¸­æ–‡ Agent)

```{python}
def run_conversation(query, api_key, model):
    """ç”Ÿæˆä¸­æ–‡æ ¼å¼çš„å¨å£«å¿Œå“é‰´ç¬”è®°"""

    # ç¬¬ 1 æ­¥ï¼šç”ŸæˆåµŒå…¥å¹¶æŸ¥æ‰¾ç›¸ä¼¼è¯„è®º
    query_embedding = get_embedding(query, api_key)
    similar_reviews = find_similar_chunks(
        query_embedding=query_embedding,
        db_path="data/whisky_database.duckdb",
        table_name="drinktony_embed",
        text_col="full",
        embedding_col="bottle_embedding"
    )

    # ç¬¬ 2 æ­¥ï¼šä¸º LLM å‡†å¤‡ä¸Šä¸‹æ–‡
    context = "\n---\n".join([review[0] for review in similar_reviews])

    # ç¬¬ 3 æ­¥ï¼šç”Ÿæˆå“é‰´ç¬”è®°
    prompt = f"""ä½œä¸ºå¨å£«å¿Œä¸“å®¶ï¼ŒåŸºäºä»¥ä¸‹å¨å£«å¿Œå“é‰´ç¬”è®°ï¼Œä¸º"{query}"ç”Ÿæˆä¸“ä¸šçš„å“é‰´æŠ¥å‘Šï¼š

å‚è€ƒå“é‰´ç¬”è®°ï¼š
{context}

è¯·æŒ‰ä»¥ä¸‹æ ¼å¼è¾“å‡ºï¼š
{query}
é—»é¦™: [è¯¦ç»†æè¿°]
å“å‘³: [è¯¦ç»†æè¿°]
æ‰“åˆ†: [90-100åˆ†]
"""

    response = llm_client.chat.completions.create(
        model=model,
        messages=[
            {"role": "system", "content": "ä½ æ˜¯ä¸€ä½ä¸“ä¸šçš„å¨å£«å¿Œå“é‰´å¸ˆï¼Œæ“…é•¿ç”Ÿæˆè¯¦ç»†å‡†ç¡®çš„å“é‰´ç¬”è®°ã€‚"},
            {"role": "user", "content": prompt}
        ],
        temperature=0.7,
        max_tokens=1000
    )

    return response.choices[0].message.content
```

### WhiskyFunny (è‹±æ–‡ Agent)

```{python}
def run_conversation(query, api_key, model):
    """ç”Ÿæˆè‹±æ–‡æ ¼å¼çš„å¨å£«å¿Œå“é‰´ç¬”è®°"""

    query_embedding = get_embedding(query, api_key)
    similar_reviews = find_similar_chunks(
        query_embedding=query_embedding,
        db_path="data/whisky_database.duckdb",
        table_name="whiskyfun_embed",
        text_col="full",
        embedding_col="bottle_embedding"
    )

    context = "\n---\n".join([review[0] for review in similar_reviews])

    prompt = f"""As a whisky expert, generate professional tasting notes for "{query}" based on these reference reviews:

Reference reviews:
{context}

Please output in this format:
Colour: [detailed description]
Nose: [detailed aroma description]
Mouth: [detailed taste description]
Finish: [detailed finish description]
Comments: [overall impression]
SGP: xxx - xx points
"""

    response = llm_client.chat.completions.create(
        model=model,
        messages=[
            {"role": "system", "content": "You are a professional whisky taster specializing in detailed sensory analysis."},
            {"role": "user", "content": prompt}
        ],
        temperature=0.7,
        max_tokens=1200
    )

    return response.choices[0].message.content
```

## æ¨èå¼•æ“

### åŒ LLM æ¨èç³»ç»Ÿ

åº”ç”¨ä½¿ç”¨ä¸€ä¸ªç‹¬ç«‹çš„ LLM æ¥ç”Ÿæˆå¨å£«å¿Œæ¨èå»ºè®®ï¼š

```{python}
def recommend_whiskies_by_profile(tasting_notes, api_key, model):
    """åŸºäºå“é‰´ç‰¹å¾ç”Ÿæˆå¨å£«å¿Œæ¨è"""

    prompt = f"""Based on these tasting notes, recommend 2 similar whiskies that the user might enjoy:

{Tasting Notes:}
{tasting_notes}

Please provide:
1. Whisky name with brief description
2. Why it matches the user's preference
3. Price range and availability

Format each recommendation as:
**Recommendation [1/2]:** [Whisky Name]
**Why it matches:** [detailed reasoning]
**Details:** [price, availability, tasting profile]
"""

    response = recommendation_client.chat.completions.create(
        model=model,  # æ¨èä½¿ç”¨ä¸åŒçš„æ¨¡å‹
        messages=[
            {"role": "system", "content": "You are a whisky recommendation expert with deep knowledge of global whisky brands and profiles."},
            {"role": "user", "content": prompt}
        ],
        temperature=0.8,
        max_tokens=800
    )

    return response.choices[0].message.content
```

## ç”¨æˆ·ç•Œé¢è®¾è®¡

### Streamlit å®ç°

```{python}
# ä¸»åº”ç”¨ç¨‹åºç•Œé¢
def main():
    st.set_page_config(
        page_title="AI å¨å£«å¿Œå“é‰´ç³»ç»Ÿ",
        page_icon="ğŸ¥ƒ",
        layout="wide"
    )

    # ä¾§è¾¹æ  Agent é€‰æ‹©
    with st.sidebar:
        st.header("ğŸ¥ƒ å¨å£«å¿Œ AI å“é‰´")

        # Agent é€‰æ‹©
        agent_type = st.selectbox(
            "é€‰æ‹©å“é‰´ Agent:",
            ["DrunkTony (ä¸­æ–‡)", "WhiskyFunny (English)", "WhiskyNotebook (English)"],
            help="æ¯ä¸ª Agent éƒ½æœ‰ä¸åŒçš„æ€§æ ¼å’Œæ•°æ®æº"
        )

        # æ¨¡å‹é€‰æ‹©
        model_options = get_model_options(agent_type)
        selected_model = st.selectbox("æ¨¡å‹:", model_options)

    # ä¸»å†…å®¹åŒºåŸŸ
    st.header("ä¸“ä¸šçš„å¨å£«å¿Œå“é‰´ç¬”è®°ç”Ÿæˆå™¨")

    # è¾“å…¥éƒ¨åˆ†
    col1, col2 = st.columns([2, 1])
    with col1:
        whisky_name = st.text_input(
            "è¾“å…¥å¨å£«å¿Œåç§°:",
            placeholder="ä¾‹å¦‚: Macallan 18 Year Old",
            help="è¾“å…¥å®Œæ•´çš„å¨å£«å¿Œåç§°ï¼ŒåŒ…æ‹¬å¹´ä»½å’Œæ¡¶å‹"
        )

    with col2:
        st.write("")  # é—´è·
        generate_btn = st.button("ğŸ· ç”Ÿæˆå“é‰´ç¬”è®°", type="primary")
        recommend_btn = st.button("ğŸ¯ è·å–æ¨è")

    # è¾“å‡ºéƒ¨åˆ†
    if generate_btn:
        if not whisky_name:
            st.error("è¯·è¾“å…¥å¨å£«å¿Œåç§°")
        else:
            with st.spinner("æ­£åœ¨åˆ†æå¨å£«å¿Œ..."):
                tasting_notes = generate_tasting_notes(whisky_name, agent_type, selected_model)
                st.markdown("### ğŸ¥ƒ å“é‰´ç¬”è®°")
                st.markdown(tasting_notes)

    if recommend_btn:
        with st.spinner("æ­£åœ¨æŸ¥æ‰¾æ¨è..."):
            recommendations = get_recommendations(tasting_notes, agent_type)
            st.markdown("### ğŸ¯ ä¸ªæ€§åŒ–æ¨è")
            st.markdown(recommendations)
```



## é¢‘ç‡é™åˆ¶ä¸æˆæœ¬ç®¡ç†

### API ä½¿ç”¨æ§åˆ¶

```{python}
# é¢‘ç‡é™åˆ¶å®ç°
RATE_LIMIT_FILE = "rate_limit.json"
MAX_RUNS_PER_DAY = 80

def get_rate_limit_data():
    """è·å–å½“å‰ä½¿ç”¨æ•°æ®"""
    try:
        with open(RATE_LIMIT_FILE, "r") as f:
            data = json.load(f)
            # ç¡®ä¿é”®å­˜åœ¨
            if "date" not in data or "count" not in data:
                return {"date": str(datetime.date.today()), "count": 0}
            return data
    except (FileNotFoundError, json.JSONDecodeError):
        return {"date": str(datetime.date.today()), "count": 0}

def check_rate_limit():
    """æ£€æŸ¥ç”¨æˆ·æ˜¯å¦è¶…å‡ºäº†æ¯æ—¥é™åˆ¶"""
    data = get_rate_limit_data()
    today = str(datetime.date.today())

    if data["date"] != today:
        # ä¸ºæ–°çš„ä¸€å¤©é‡ç½®è®¡æ•°å™¨
        return {"date": today, "count": 0, "can_run": True}

    if data["count"] >= MAX_RUNS_PER_DAY:
        return {"date": today, "count": data["count"], "can_run": False}

    return {"date": today, "count": data["count"], "can_run": True}
```

## æ€§èƒ½ä¼˜åŒ–

### å‘é‡æ•°æ®åº“æ€§èƒ½

```{python}
# é’ˆå¯¹å¤§æ•°æ®çš„åˆ†æ‰¹ä¼˜åŒ–ç›¸ä¼¼åº¦æœç´¢
def batch_similarity_search(query_embedding, db_path, table_name, batch_size=1000):
    """é’ˆå¯¹å¤§å‹æ•°æ®é›†çš„åˆ†æ‰¹ç›¸ä¼¼åº¦æœç´¢ä¼˜åŒ–"""

    with duckdb.connect(database=db_path, read_only=True) as con:
        # è·å–æ€»è¡Œæ•°
        total_rows = con.execute(f"SELECT COUNT(*) FROM {table_name}").fetchone()[0]

        all_similarities = []

        # åˆ†æ‰¹å¤„ç†ä»¥ç®¡ç†å†…å­˜
        for offset in range(0, total_rows, batch_size):
            batch_df = con.execute(
                f'SELECT full, bottle_embedding FROM {table_name} LIMIT {batch_size} OFFSET {offset}'
            ).fetchdf()

            # è®¡ç®—è¯¥æ‰¹æ¬¡çš„ç›¸ä¼¼åº¦
            for _, row in batch_df.iterrows():
                embedding = np.array(row['bottle_embedding'])
                similarity = cosine_similarity(query_embedding, embedding)
                all_similarities.append((row['full'], similarity))

        # æ’åºå¹¶è¿”å›å‰å‡ æ¡ç»“æœ
        all_similarities.sort(key=lambda x: x[1], reverse=True)
        return all_similarities[:10]
```

## éƒ¨ç½²ä¸é…ç½®

### ç¯å¢ƒæ­å»º

```bash
# .env æ–‡ä»¶ä¸­çš„ç¯å¢ƒå˜é‡
SILICONFLOW_API_KEY=æ‚¨çš„ SiliconFlow å¯†é’¥
MODELSCOPE_API_KEY=æ‚¨çš„ ModelScope å¯†é’¥
GEMINI_API_KEY=æ‚¨çš„ Gemini å¯†é’¥  # å¯é€‰

# æ•°æ®åº“åˆå§‹åŒ–
python -c "
import duckdb
conn = duckdb.connect('data/whisky_database.duckdb')
# åˆ›å»ºæ”¯æŒå‘é‡çš„è¡¨æ ¼
"
```


### Shiny for Python å¤‡é€‰æ–¹æ¡ˆ

```{python}
# ä½¿ç”¨ Shiny å®ç°çš„å¤‡é€‰ UI
from shiny import App, ui, render, reactive, req

app_ui = ui.page_fluid(
    ui.h2("ğŸ¥ƒ AI å¨å£«å¿Œå“é‰´ç³»ç»Ÿ"),
    ui.layout_sidebar(
        ui.sidebar(
            ui.input_select("agent", "é€‰æ‹© Agent:", [
                "DrunkTony (ä¸­æ–‡)", "WhiskyFunny (English)", "WhiskyNotebook (English)"
            ]),
            ui.input_text("whisky_name", "å¨å£«å¿Œåç§°:", ""),
            ui.input_action_button("generate", "ç”Ÿæˆå“é‰´ç¬”è®°")
        ),
        ui.output_text_verbatim("tasting_notes"),
        ui.output_text_verbatim("recommendations")
    )
)

def server(input, output, session):
    @output
    @render.text
    def tasting_notes():
        req(input.generate())
        # ç”Ÿæˆå“é‰´ç¬”è®°é€»è¾‘
        return generate_tasting_notes(input.whisky_name(), input.agent())

app = App(app_ui, server)
```


## æŠ€æœ¯æˆå°±

### æ ¸å¿ƒåˆ›æ–°

1. **å¤š Agent æ¶æ„**: æ‹¥æœ‰ä¸åŒçš„ AI äººæ ¼å’Œæ•°æ®æºã€‚
2. **RAG å®ç°**: ä½¿ç”¨çœŸå®å¨å£«å¿Œè¯„è®ºè¿›è¡Œæ£€ç´¢å¢å¼ºç”Ÿæˆã€‚
3. **å‘é‡æ•°æ®åº“**: ä½¿ç”¨ 376MB æ•°æ®åº“è¿›è¡Œé«˜æ•ˆç›¸ä¼¼åº¦æœç´¢ã€‚
4. **åŒè¯­æ”¯æŒ**: æä¾›ä¸­æ–‡å’Œè‹±æ–‡ Agentã€‚
5. **æˆæœ¬ç®¡ç†**: å†…ç½®é¢‘ç‡é™åˆ¶å’Œ API ä¼˜åŒ–ã€‚
6. **ä¸“ä¸šå“é‰´æ ¼å¼**: ç¬¦åˆè¡Œä¸šæ ‡å‡†çš„ç¬”è®°ç»“æ„ã€‚

### æ€§èƒ½æŒ‡æ ‡

| æŒ‡æ ‡ | æ•°å€¼ |
|--------|-------|
| æ•°æ®åº“å¤§å° | 376MB (26,000+ æ¡è¯„è®º) |
| åµŒå…¥ç»´åº¦ | 1024 |
| æœç´¢å»¶è¿Ÿ | < 2 ç§’ |
| æ¯æ—¥è¯·æ±‚é™åˆ¶ | 80 æ¬¡è¯·æ±‚ |
| æ”¯æŒè¯­è¨€ | 2 (EN/ZH) |
| æ•°æ®æº | 3 (drinktony, whiskyfun, whiskynotes) |

## æœªæ¥å¢å¼ºæ–¹å‘

ä¸‹ä¸€ç‰ˆæœ¬çš„æ½œåœ¨æ”¹è¿›ç‚¹ï¼š

1. **é«˜çº§ç›¸ä¼¼åº¦ç®—æ³•**: å®ç°æ–‡æœ¬ + å…ƒæ•°æ®çš„æ··åˆæœç´¢ã€‚
2. **ç”¨æˆ·ä¸ªæ€§åŒ–**: éšç€æ—¶é—´æ¨ç§»å­¦ä¹ ç”¨æˆ·çš„åå¥½ã€‚
3. **ç§»åŠ¨ç«¯åº”ç”¨**: åŸç”Ÿçš„ iOS/Android åº”ç”¨ç¨‹åºã€‚
4. **å®æ—¶æ•°æ®æ›´æ–°**: è‡ªåŠ¨åŒ–çš„ç½‘é¡µæŠ“å–æµæ°´çº¿ã€‚
5. **å£å‘³ç‰¹å¾åˆ†æ**: æ ¹æ®ç”¨æˆ·åå¥½ç”Ÿæˆå…¶å£å‘³ç‰¹å¾å›¾è°±ã€‚
6. **ç¤¾äº¤åŠŸèƒ½**: ä¸ç¤¾åŒºåˆ†äº«å“é‰´ç¬”è®°å’Œæ¨èã€‚

## ç»“è®º

è¿™æ¬¾å¨å£«å¿Œå“é‰´åº”ç”¨å±•ç¤ºäº†å°† RAG æŠ€æœ¯ä¸ä¸“é—¨çš„ AI Agent ç›¸ç»“åˆï¼Œä»è€Œæ„å»ºå¤æ‚çš„é¢†åŸŸç‰¹å®šç³»ç»Ÿçš„å¼ºå¤§åŠ›é‡ã€‚æœ¬é¡¹ç›®å±•ç¤ºäº†ï¼š

- **å…ˆè¿›çš„ AI æ¶æ„**: å…·å¤‡ä¸åŒäººæ ¼çš„å¤š Agent ç³»ç»Ÿã€‚
- **æ•°æ®å·¥ç¨‹**: å¤§è§„æ¨¡å‘é‡æ•°æ®åº“ç®¡ç†ã€‚
- **ä¸“ä¸šçŸ¥è¯†**: è¡Œä¸šæ ‡å‡†çš„å“é‰´ç¬”è®°æ ¼å¼ã€‚
- **ç”¨æˆ·ä½“éªŒ**: è·¨å¹³å°çš„ç®€æ´ã€ç›´è§‚ç•Œé¢ã€‚
- **æˆæœ¬æ•ˆç›Š**: æ™ºèƒ½çš„é¢‘ç‡é™åˆ¶å’Œä¼˜åŒ–ã€‚

æ— è®ºæ‚¨æ˜¯å¨å£«å¿Œçˆ±å¥½è€…ã€AI å¼€å‘äººå‘˜è¿˜æ˜¯æ•°æ®ç§‘å­¦å®¶ï¼Œæœ¬é¡¹ç›®éƒ½ä¸ºæ‚¨æä¾›äº†ä¸€ä¸ªæä½³çš„èŒƒä¾‹ï¼Œå±•ç¤ºäº†å¦‚ä½•ç»“åˆçœŸå®ä¸–ç•Œæ•°æ®ä¸å…ˆè¿›æœºå™¨å­¦ä¹ æŠ€æœ¯æ¥æ„å»ºç”Ÿäº§çº§ AI åº”ç”¨ã€‚

---


**æŠ€æœ¯æ ˆ**: Python, Streamlit, DuckDB, OpenAI API, å‘é‡åµŒå…¥ (Vector Embeddings)

**æ•°æ®åº“**: æ¶µç›– 3 ä¸ªä¸“é—¨æ¥æºçš„ 26,000+ æ¡çœŸå®å¨å£«å¿Œè¯„è®ºã€‚