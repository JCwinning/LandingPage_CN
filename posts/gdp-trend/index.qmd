---
title: "ä½¿ç”¨ AI SQL æ„å»ºçš„äº¤äº’å¼ GDP è¶‹åŠ¿çœ‹æ¿"
date: "2025-11-18"
categories: [Data Visualization, Streamlit, Economic Analysis, AI]
image: "images/0.png"

format:
  html:
    code-fold: true
    code-tools: true
    code-copy: true
    
execute:
  eval: false
  warning: false
---

# é¡¹ç›®æ¦‚è§ˆ

GDP è¶‹åŠ¿çœ‹æ¿ (GDP Trend Dashboard) æ˜¯ä¸€ä¸ªå¤æ‚çš„ Web åº”ç”¨ç¨‹åºï¼Œç”¨äºå¯è§†åŒ–å’Œåˆ†ææ¥è‡ªä¸–ç•Œé“¶è¡Œ API çš„ç»æµæ•°æ®ã€‚è¯¥ç³»ç»Ÿçš„ç‹¬ç‰¹ä¹‹å¤„åœ¨äºå…¶åŒé‡æ–¹æ³•ï¼šå°†ä¼ ç»Ÿçš„äº¤äº’å¼å¯è§†åŒ–ä¸ AI é©±åŠ¨çš„è‡ªç„¶è¯­è¨€æŸ¥è¯¢ç›¸ç»“åˆï¼Œä½¿æŠ€æœ¯åˆ†æå¸ˆå’Œæ™®é€šç”¨æˆ·éƒ½èƒ½è½»æ¾è·å–ç»æµæ•°æ®ã€‚


åœ¨çº¿æ¼”ç¤ºï¼š[https://world-GDP-trend.streamlit.app](https://world-GDP-trend.streamlit.app)

Githubï¼š[https://github.com/JCwinning/GDP_trend](https://github.com/JCwinning/GDP_trend)

::: {.panel-tabset}

## GDP è¶‹åŠ¿

äº¤äº’å¼å…¨çƒ GDP è¶‹åŠ¿å¯è§†åŒ–

![](images/0.png){width="100%"}


## AI æŸ¥è¯¢ç•Œé¢

äº¤äº’å¼ AI é©±åŠ¨çš„è‡ªç„¶è¯­è¨€è½¬ SQL

![](images/1.png){width="100%"}


## AI æ‘˜è¦ç”Ÿæˆ

AI ç”Ÿæˆçš„ç»æµæ•°æ®æ´è§æ‘˜è¦

![](images/2.png){width="100%"}


:::



## æ ¸å¿ƒæ¶æ„

### æŠ€æœ¯æ ˆ

- **ä¸»è¦æ¡†æ¶**ï¼šç”¨äºäº¤äº’å¼ Web åº”ç”¨çš„ Streamlit
- **æ•°æ®å¤„ç†**ï¼šç”¨äºæ•°æ®æ“ä½œå’Œåˆ†æçš„ Pandas
- **å¯è§†åŒ–**ï¼šç”¨äºäº¤äº’å¼å›¾è¡¨çš„ Plotly Express
- **æ•°æ®åº“**ï¼šç”¨äºé«˜æ•ˆ SQL æŸ¥è¯¢çš„ DuckDB
- **AI é›†æˆ**ï¼šç”¨äºè‡ªç„¶è¯­è¨€è½¬ SQL çš„ ModelScope GLM-4.6
- **æ•°æ®æº**ï¼šé€šè¿‡ `wbgapi` åº“è°ƒç”¨çš„ä¸–ç•Œé“¶è¡Œ API

### å…³é”®ç‰¹æ€§

1. **å¤šå›½ GDP è¶‹åŠ¿å¯¹æ¯”**
2. **æ”¯æŒå¤šç§ç»æµæŒ‡æ ‡**ï¼ˆGDPã€äººå‡ GDPã€äººå£ã€åŒæ¯”å¢é•¿ç‡ï¼‰
3. **AI é©±åŠ¨çš„è‡ªç„¶è¯­è¨€æŸ¥è¯¢**
4. **ä½¿ç”¨ DuckDB çš„ç›´æ¥ SQL æ¥å£**
5. **å®Œå–„çš„åŒè¯­æ”¯æŒ**ï¼ˆä¸­/è‹±æ–‡ï¼‰
6. **å¸¦äº¤äº’æ§åˆ¶çš„æ—¶é—´èŒƒå›´ç­›é€‰**ï¼ˆ2000å¹´è‡³ä»Šï¼‰

## æ•°æ®æµæ°´çº¿æ¶æ„

è¯¥åº”ç”¨ç¨‹åºå®ç°äº†ä¸€ä¸ªå¤æ‚çš„æ•°æ®æµæ°´çº¿ï¼Œä»¥ç¡®ä¿æ•°æ®è´¨é‡å’Œå®æ—¶å¯ç”¨æ€§ï¼š





```{mermaid}
%%| eval: true
%%| fig-cap: "GDP åº”ç”¨æ¶æ„"

flowchart TD
    A[ä¸–ç•Œé“¶è¡Œ API] --> B[æ•°æ®é‡‡é›†<br/>download_data.py]
    B --> C[æ•°æ®å¤„ç†<br/>å›½å®¶æ˜ å°„ã€æŒ‡æ ‡è®¡ç®—]
    C --> D[æ•°æ®å­˜å‚¨<br/>CSV æ–‡ä»¶]

    D --> E[Streamlit åº”ç”¨<br/>app.py]
    E --> F[DuckDB<br/>å†…å­˜ SQL]

    F --> G[å¯è§†åŒ–å¼•æ“<br/>Plotly Express]
    F --> H[AI æŸ¥è¯¢å¼•æ“<br/>ModelScope API]
    F --> I[ä¼šè¯ç®¡ç†<br/>ç”¨æˆ·çŠ¶æ€]

    G --> J[äº¤äº’å¼å›¾è¡¨]
    H --> K[è‡ªç„¶è¯­è¨€<br/>è½¬ SQL]
    I --> L[æŒä¹…åŒ–<br/>æŸ¥è¯¢ç»“æœ]

    J --> M[ç”¨æˆ·ç•Œé¢]
    K --> M
    L --> M
```

## æ•°æ®é‡‡é›†ä¸å¤„ç†

### ä¸–ç•Œé“¶è¡Œ API é›†æˆ

åº”ç”¨ç¨‹åºä½¿ç”¨ä¸–ç•Œé“¶è¡Œ API é‡‡é›†å…¨é¢çš„ç»æµæ•°æ®ï¼š

```{python}
import wbgapi as wb
import pycountry
import pandas as pd

def download_economic_data():
    """ä»ä¸–ç•Œé“¶è¡Œ API ä¸‹è½½æ‰€æœ‰å›½å®¶çš„ GDP æ•°æ®"""

    # å®šä¹‰è¦ä¸‹è½½çš„ç»æµæŒ‡æ ‡
    indicators = {
        'gdp_current_usd': 'NY.GDP.MKTP.CD',
        'gdp_per_capita_current_usd': 'NY.GDP.PCAP.CD',
        'population_total': 'SP.POP.TOTL'
    }

    # ä¸‹è½½ 2000 å¹´è‡³ä»Šçš„æ•°æ®
    data_frames = []
    for indicator_name, indicator_code in indicators.items():
        df = wb.get_series(
            series=indicator_code,
            economy='all',
            time='2000:2024',
            simplify_index=True
        )

        # å¤„ç†å¹¶æ·»åŠ åˆ°é›†åˆ
        df = df.reset_index()
        df['indicator'] = indicator_name
        data_frames.append(df)

    # åˆå¹¶æ‰€æœ‰æŒ‡æ ‡
    combined_df = pd.concat(data_frames, ignore_index=True)
    return combined_df

def create_country_reference_table():
    """åˆ›å»ºåŒ…å« ISO ä»£ç çš„å®Œæ•´å›½å®¶å…ƒæ•°æ®è¡¨"""
    countries = list(pycountry.countries)

    df_all = pd.DataFrame([{
        'country_name': country.name,
        'country_code_2': country.alpha_2,
        'country_code_3': country.alpha_3
    } for country in countries])

    # æ·»åŠ å¤§æ´²æ˜ å°„
    iso_to_continent = {
        "US": "North America", "CN": "Asia", "JP": "Asia",
        "DE": "Europe", "GB": "Europe", "FR": "Europe"
        # ... ä¸ºæ‰€æœ‰å›½å®¶å®Œæˆæ˜ å°„
    }

    df_all['continent'] = df_all['country_code_2'].map(iso_to_continent)
    return df_all
```

### æ•°æ®æ¨¡å¼ä¸ç»“æ„

åº”ç”¨ç¨‹åºä½¿ç”¨æ¸…æ™°ã€è§„èŒƒåŒ–çš„æ•°æ®ç»“æ„ï¼š

```{python}
-- ä¸»è¦æ•°æ®æ¨¡å¼
CREATE TABLE df_gdp (
    country_name TEXT,        -- æ˜¾ç¤ºåç§° (è‹±æ–‡)
    country_code_2 TEXT,      -- ISO alpha-2 ä»£ç 
    country_code_3 TEXT,      -- ISO alpha-3 ä»£ç 
    continent TEXT,            -- å¤§æ´²åˆ†ç±»
    year INTEGER,              -- æ•°æ®å¹´ä»½
    indicator TEXT,            -- ç»æµæŒ‡æ ‡åç§°
    value REAL                -- æŒ‡æ ‡æ•°å€¼
);

-- ç¤ºä¾‹æ•°æ®
INSERT INTO df_gdp VALUES
('United States', 'US', 'USA', 'North America', 2023, 'gdp_current_usd', 27444144.3),
('United States', 'US', 'USA', 'North America', 2023, 'gdp_per_capita_current_usd', 81254.2),
('United States', 'US', 'USA', 'North America', 2023, 'population_total', 334914895.0);
```

## äº¤äº’å¼å¯è§†åŒ–ç³»ç»Ÿ

### Plotly Express å®ç°

åº”ç”¨ç¨‹åºä½¿ç”¨ Plotly Express åˆ›å»ºäº¤äº’å¼å›¾è¡¨ï¼Œå¹¶ä¿æŒä¸€è‡´çš„é¢œè‰²ç¼–ç ï¼š

```{python}
import plotly.express as px

@st.cache_data
def load_data():
    """åŠ è½½å¹¶ç¼“å­˜ GDP æ•°æ®"""
    return pd.read_csv('data/gdp_data_2000_present.csv')

def create_gdp_trend_chart(selected_countries, selected_indicator, year_range):
    """åˆ›å»ºäº¤äº’å¼ GDP è¶‹åŠ¿å¯è§†åŒ–"""

    # åŠ è½½ç­›é€‰åçš„æ•°æ®
    df = load_data()

    # åº”ç”¨ç­›é€‰æ¡ä»¶
    filtered_df = df[
        (df['country_name'].isin(selected_countries)) &
        (df['indicator'] == selected_indicator) &
        (df['year'].between(year_range[0], year_range[1]))
    ]

    # åˆ›å»ºäº¤äº’å¼æŠ˜çº¿å›¾
    fig = px.line(
        filtered_df,
        x='year',
        y='value',
        color='country_name',
        title=f'{selected_indicator.replace("_", " ").title()} è¶‹åŠ¿',
        labels={
            'year': 'å¹´ä»½',
            'value': format_indicator_label(selected_indicator),
            'country_name': 'å›½å®¶'
        }
    )

    # è‡ªå®šä¹‰å›¾è¡¨å¤–è§‚
    fig.update_layout(
        xaxis_title="å¹´ä»½",
        yaxis_title=format_indicator_label(selected_indicator),
        hovermode='x unified',
        showlegend=True,
        legend=dict(
            orientation="h",
            yanchor="bottom",
            y=1.02,
            xanchor="right",
            x=1
        )
    )

    return fig

def format_indicator_label(indicator):
    """æ ¼å¼åŒ–æŒ‡æ ‡åç§°ä»¥ä¾›æ˜¾ç¤º"""
    labels = {
        'gdp_current_usd': 'GDP (ç°ä»·ç¾å…ƒ)',
        'gdp_per_capita_current_usd': 'äººå‡ GDP (ç°ä»·ç¾å…ƒ)',
        'population_total': 'æ€»äººå£',
        'gdp_per_capita_current_usd_yoy': 'äººå‡ GDP åŒæ¯”å¢é•¿ç‡ (%)'
    }
    return labels.get(indicator, indicator.replace('_', ' ').title())
```

## AI é©±åŠ¨çš„åˆ†æ

### è‡ªç„¶è¯­è¨€è½¬ SQL

è¯¥ç¨‹åºæœ€å…·åˆ›æ–°æ€§çš„åŠŸèƒ½æ˜¯ AI é©±åŠ¨çš„è‡ªç„¶è¯­è¨€æŸ¥è¯¢ï¼š

```{python}
from openai import OpenAI
import duckdb

def generate_sql_from_question(question, language):
    """ä½¿ç”¨ ModelScope API å°†è‡ªç„¶è¯­è¨€é—®é¢˜è½¬æ¢ä¸º SQL æŸ¥è¯¢"""

    # è·å–æ•°æ®åº“æ¨¡å¼ä¸Šä¸‹æ–‡
    schema_info = """
    è¡¨å: df_gdp
    åˆ—å:
    - country_name (TEXT): å›½å®¶æ˜¾ç¤ºåç§°
    - country_code_2 (TEXT): ISO alpha-2 å›½å®¶ä»£ç 
    - continent (TEXT): å¤§æ´²åˆ†ç±»
    - year (INTEGER): æ•°æ®å¹´ä»½ (2000-2024)
    - indicator (TEXT): ç»æµæŒ‡æ ‡åç§°
    - value (REAL): æŒ‡æ ‡æ•°å€¼

    å¯ç”¨æŒ‡æ ‡:
    - gdp_current_usd: ç°ä»· GDP (ç¾å…ƒ)
    - gdp_per_capita_current_usd: ç°ä»·äººå‡ GDP (ç¾å…ƒ)
    - population_total: æ€»äººå£
    - gdp_per_capita_current_usd_yoy: äººå‡ GDP åŒæ¯”å¢é•¿ç‡ (%)
    """

    # åˆ›å»ºç‰¹å®šè¯­è¨€çš„æç¤ºè¯
    if language == "zh":
        prompt = f"""è¯·å°†ä»¥ä¸‹è‡ªç„¶è¯­è¨€é—®é¢˜è½¬æ¢ä¸ºSQLæŸ¥è¯¢ï¼Œä»…è¿”å›SQLè¯­å¥ï¼Œä¸è¦è§£é‡Šã€‚

æ•°æ®åº“ä¿¡æ¯ï¼š
{schema_info}

ç”¨æˆ·é—®é¢˜ï¼š{question}

è¦æ±‚ï¼š
1. åªè¿”å›æ ‡å‡†çš„SELECTè¯­å¥
2. ä¸è¦æ·»åŠ ä»»ä½•è§£é‡Šæˆ–æ³¨é‡Š
3. ä½¿ç”¨LIMIT 50é™åˆ¶ç»“æœæ•°é‡"""
    else:
        # (ä¿æŒåŸè‹±æ–‡ prompt)
        prompt = f"""Convert the following natural language question to SQL query. Return only the SQL statement, no explanation.

Database information:
{schema_info}

User question: {question}

Requirements:
1. Return only standard SELECT statement
2. Do not add any explanation or comments
3. Use LIMIT 50 to restrict results"""

    # è°ƒç”¨ ModelScope API
    client = OpenAI(
        api_key=os.getenv('MODELSCOPE_API_KEY'),
        base_url="https://dashscope.aliyuncs.com/compatible-mode/v1"
    )

    response = client.chat.completions.create(
        model="qwen/Qwen3-235B",
        messages=[{"role": "user", "content": prompt}],
        temperature=0.1,  # ä½¿ç”¨ä½æ¸©åº¦ä»¥è·å¾—ä¸€è‡´çš„ SQL
        max_tokens=500
    )

    return response.choices[0].message.content.strip()
```

### æŸ¥è¯¢æ‰§è¡Œä¸ AI æ‘˜è¦

```{python}
def execute_query_with_ai_summary(sql_query, original_question):
    """æ‰§è¡Œ SQL æŸ¥è¯¢å¹¶ç”Ÿæˆ AI æ‘˜è¦"""

    try:
        # ä½¿ç”¨ DuckDB æ‰§è¡ŒæŸ¥è¯¢
        conn = duckdb.connect()
        result_df = conn.execute(sql_query).fetchdf()

        # å°†ç»“æœå­˜å…¥ä¼šè¯çŠ¶æ€
        st.session_state.sql_result = result_df
        st.session_state.sql_query = sql_query

        # å¦‚æœæœ‰æ•°æ®ï¼Œç”Ÿæˆ AI æ‘˜è¦
        if not result_df.empty:
            generate_ai_summary(result_df, original_question)

        return result_df

    except Exception as e:
        st.error(f"æŸ¥è¯¢æ‰§è¡Œé”™è¯¯: {str(e)}")
        return None

def generate_ai_summary(data_frame, question):
    """ç”ŸæˆæŸ¥è¯¢ç»“æœçš„ AI æ‘˜è¦"""

    # å°† DataFrame è½¬æ¢ä¸ºæ–‡æœ¬ä»¥ä¾¿åˆ†æ
    data_summary = data_frame.to_string(index=False)

    summary_prompt = f"""æ ¹æ®ä»¥ä¸‹æ•°æ®åˆ†æç»“æœï¼Œæä¾›ä¸€ä¸ªç®€æ˜æ‰¼è¦çš„æ‘˜è¦ï¼š

åŸå§‹é—®é¢˜ï¼š{question}

æŸ¥è¯¢ç»“æœï¼š
{data_summary}

è¯·æä¾›ï¼š
1. å…³é”®å‘ç°çš„ç®€è¦åˆ†æ
2. ä»»ä½•å€¼å¾—æ³¨æ„çš„è¶‹åŠ¿æˆ–æ¨¡å¼
3. æ¥è‡ªæ•°æ®çš„é‡è¦è§è§£

è¯·å°†æ‘˜è¦æ§åˆ¶åœ¨ 200 å­—ä»¥å†…ï¼Œå¹¶ç¡®ä¿é€šä¿—æ˜“æ‡‚ã€‚"""

    # ä½¿ç”¨ AI ç”Ÿæˆæ‘˜è¦
    client = OpenAI(
        api_key=os.getenv('MODELSCOPE_API_KEY'),
        base_url="https://dashscope.aliyuncs.com/compatible-mode/v1"
    )

    response = client.chat.completions.create(
        model="qwen/Qwen3-235B",
        messages=[{"role": "user", "content": summary_prompt}],
        temperature=0.3,
        max_tokens=300
    )

    st.session_state.ai_summary = response.choices[0].message.content
```

![AI æŸ¥è¯¢ç•Œé¢ - è‡ªç„¶è¯­è¨€å¤„ç†](images/1.png){width="100%"}

## åŒè¯­æ”¯æŒç³»ç»Ÿ

### å›½é™…åŒ–æ¶æ„

åº”ç”¨ç¨‹åºå®ç°äº†å…¨é¢çš„ä¸­/è‹±æ–‡æ”¯æŒï¼š

```{python}
# language.py - å®Œæ•´çš„ç¿»è¯‘ç³»ç»Ÿ
translations = {
    "en": {
        "title": "ğŸŒ GDP Trend Dashboard",
        "gdp_trend": "GDP Trend",
        "ai_powered_chat": "AI-Powered Data Chat",
        "default_question": "What is the average GDP per capita for China, Japan, and Korea during 2020 to 2023?"
    },
    "zh": {
        "title": "ğŸŒ GDP è¶‹åŠ¿çœ‹æ¿",
        "gdp_trend": "GDP è¶‹åŠ¿",
        "ai_powered_chat": "AI æ•°æ®å¯¹è¯",
        "default_question": "2020å¹´è‡³2023å¹´æœŸé—´ï¼Œä¸­å›½ã€æ—¥æœ¬å’ŒéŸ©å›½çš„å¹³å‡äººå‡GDPæ˜¯å¤šå°‘ï¼Ÿ"
    }
}

def get_text(key):
    """è·å–å½“å‰è¯­è¨€çš„ç¿»è¯‘æ–‡æœ¬"""
    language = st.session_state.get("language", "en")
    return translations.get(language, {}).get(key, key)

# UI ä¸­çš„è¯­è¨€åˆ‡æ¢
col1, col2 = st.columns([1, 1])
with col1:
    if st.button("English"):
        st.session_state.language = "en"
        st.rerun()
with col2:
    if st.button("ä¸­æ–‡"):
        st.session_state.language = "zh"
        st.rerun()
```

## ç”¨æˆ·ç•Œé¢è®¾è®¡

### ä¸»åº”ç”¨ç¨‹åºç»“æ„

```{python}
def main():
    """é‡‡ç”¨æ ‡ç­¾é¡µå¯¼èˆªçš„ä¸»åº”ç”¨ç¨‹åº"""

    # å³ä¸Šè§’çš„è¯­è¨€åˆ‡æ¢
    with st.container():
        st.markdown("""
        <div class="language-toggle">
            <button onclick="setLanguage('en')">EN</button>
            <button onclick="setLanguage('zh')">ä¸­æ–‡</button>
        </div>
        """, unsafe_allow_html=True)

    st.title(get_text("title"))

    # æ ‡ç­¾é¡µç•Œé¢
    tab1, tab2 = st.tabs([get_text("gdp_trend"), get_text("query")])

    with tab1:
        render_gdp_trends_tab()

    with tab2:
        render_query_interface_tab()

def render_gdp_trends_tab():
    """æ¸²æŸ“ GDP è¶‹åŠ¿å¯è§†åŒ–æ ‡ç­¾é¡µ"""

    st.header(get_text("gdp_trend"))

    # åŠ è½½æ•°æ®
    df = load_data()

    # ç­›é€‰æ§åˆ¶
    col1, col2, col3 = st.columns([2, 1, 1])

    with col1:
        selected_countries = st.multiselect(
            get_text("select_countries"),
            options=df['country_name'].unique(),
            default=['United States', 'China', 'Japan']
        )

    with col2:
        selected_indicator = st.selectbox(
            get_text("select_indicator"),
            options=[
                'gdp_current_usd',
                'gdp_per_capita_current_usd',
                'population_total',
                'gdp_per_capita_current_usd_yoy'
            ],
            format_func=lambda x: format_indicator_label(x)
        )

    with col3:
        year_range = st.slider(
            get_text("select_year_range"),
            min_value=2000,
            max_value=2024,
            value=(2010, 2024),
            step=1
        )

    # ç”Ÿæˆå¹¶æ˜¾ç¤ºå›¾è¡¨
    if selected_countries and selected_indicator:
        fig = create_gdp_trend_chart(selected_countries, selected_indicator, year_range)
        st.plotly_chart(fig, use_container_width=True)

        # æ˜¾ç¤ºåŸå§‹æ•°æ®é€‰é¡¹
        if st.checkbox(get_text("show_raw_data")):
            display_filtered_data_table(selected_countries, selected_indicator, year_range)

def render_query_interface_tab():
    """æ¸²æŸ“ AI é©±åŠ¨çš„æŸ¥è¯¢ç•Œé¢æ ‡ç­¾é¡µ"""

    st.header(get_text("ai_powered_chat"))
    st.markdown(get_text("ai_chat_description"))

    # è‡ªç„¶è¯­è¨€è¾“å…¥
    user_question = st.text_input(
        get_text("your_question"),
        value=st.session_state.get("user_question", get_text("default_question"))
    )

    col1, col2 = st.columns([1, 1])

    with col1:
        if st.button(get_text("run_ai"), type="primary"):
            if user_question:
                with st.spinner("AI æ­£åœ¨å¤„ç†..."):
                    # ä»è‡ªç„¶è¯­è¨€ç”Ÿæˆ SQL
                    sql_query = generate_sql_from_question(
                        user_question,
                        st.session_state.language
                    )

                    if sql_query:
                        # æ‰§è¡ŒæŸ¥è¯¢å¹¶ç”Ÿæˆæ‘˜è¦
                        result_df = execute_query_with_ai_summary(sql_query, user_question)

                        st.session_state.user_question = user_question
                        st.session_state.should_generate_ai_summary = True

    # æ˜¾ç¤ºç»“æœ
    if st.session_state.get("sql_result") is not None:
        display_query_results()
```

## æ€§èƒ½ä¼˜åŒ–

### æ•°æ®ç¼“å­˜ä¸æ•ˆç‡

```{python}
# Streamlit æ•°æ®æ“ä½œç¼“å­˜
@st.cache_data(ttl=3600)  # ç¼“å­˜ 1 å°æ—¶
def load_data():
    """åŠ è½½å¹¶ç¼“å­˜ GDP æ•°æ®"""
    return pd.read_csv('data/gdp_data_2000_present.csv')

@st.cache_data(ttl=1800)  # ç¼“å­˜ 30 åˆ†é’Ÿ
def get_country_list():
    """è·å–å¹¶ç¼“å­˜å”¯ä¸€çš„å›½å®¶åˆ—è¡¨"""
    df = load_data()
    return sorted(df['country_name'].unique())

# AI äº¤äº’çš„ä¼šè¯çŠ¶æ€ç®¡ç†
def init_session_state():
    """åˆå§‹åŒ–æ‰€æœ‰ä¼šè¯çŠ¶æ€å˜é‡"""
    if "sql_result" not in st.session_state:
        st.session_state.sql_result = None
    if "ai_summary" not in st.session_state:
        st.session_state.ai_summary = None
    if "should_generate_ai_summary" not in st.session_state:
        st.session_state.should_generate_ai_summary = False
```

### é”™è¯¯å¤„ç†ä¸ç”¨æˆ·ä½“éªŒ

```{python}
def safe_api_call(func, *args, **kwargs):
    """å¸¦é”™è¯¯å¤„ç†çš„å®‰å…¨ API è°ƒç”¨"""
    try:
        return func(*args, **kwargs)
    except Exception as e:
        st.error(f"API é”™è¯¯: {str(e)}")
        return None

def validate_sql_query(sql_query):
    """åŸºç¡€ SQL æŸ¥è¯¢éªŒè¯"""
    sql_lower = sql_query.lower().strip()

    # åŸºç¡€å®‰å…¨æ£€æŸ¥
    dangerous_keywords = ['drop', 'delete', 'update', 'insert', 'alter']
    for keyword in dangerous_keywords:
        if keyword in sql_lower:
            raise ValueError(f"æ£€æµ‹åˆ°å±é™© SQL å…³é”®å­—: {keyword}")

    # ç¡®ä¿æŸ¥è¯¢ä»¥ SELECT å¼€å¤´
    if not sql_lower.startswith('select'):
        raise ValueError("ä»…å…è®¸æ‰§è¡Œ SELECT æŸ¥è¯¢")

    return True
```

## éƒ¨ç½²ä¸å¯è®¿é—®æ€§

### ç¯å¢ƒé…ç½®

```bash
# ç¯å¢ƒé…ç½®
# .env æ–‡ä»¶
MODELSCOPE_API_KEY=your_modelscope_key

# å®‰è£…ä¾èµ–
pip install -r requirements.txt

# æ•°æ®é‡‡é›†
python download_data.py

# è¿è¡Œåº”ç”¨ç¨‹åº
streamlit run app.py
```

### å¿…éœ€çš„ä¾èµ–é¡¹

```txt
streamlit>=1.28.0
pandas>=1.5.0
plotly>=5.15.0
duckdb>=0.8.0
openai>=1.0.0
python-dotenv>=1.0.0
wbgapi>=1.0.0
pycountry>=22.0.0
numpy>=1.24.0
```

## æŠ€æœ¯äº®ç‚¹

### å…³é”®åˆ›æ–°ç‚¹

1. **åŒç•Œé¢æ–¹æ¡ˆ**ï¼šåŒæ—¶æä¾›è§†è§‰å’Œè‡ªç„¶è¯­è¨€è®¿é—®æ•°æ®çš„æ–¹å¼
2. **AI é©±åŠ¨çš„ SQL ç”Ÿæˆ**ï¼šä½¿ç”¨ç®€å•çš„ä¸­/è‹±æ–‡å³å¯è¿›è¡Œå¤æ‚çš„ç»æµæŸ¥è¯¢
3. **å®æ—¶æ•°æ®å¤„ç†**ï¼šé«˜æ•ˆçš„ç¼“å­˜å’Œä¼šè¯ç®¡ç†
4. **å…¨é¢çš„å›½é™…åŒ–**ï¼šçœŸæ­£çš„åŒè¯­æ”¯æŒåŠæœ¬åœ°åŒ–æ•°æ®æ˜¾ç¤º
5. **ç”Ÿäº§å°±ç»ªçš„éƒ¨ç½²**ï¼šå®Œå–„çš„é”™è¯¯å¤„ç†å’Œæ€§èƒ½ä¼˜åŒ–


![AI æ‘˜è¦ç”Ÿæˆ](images/2.png){width="100%"}

## ç»æµåˆ†æç¤ºä¾‹

### æ”¯æŒçš„æŸ¥è¯¢ç±»å‹

1. **å¯¹æ¯”åˆ†æ**
   - "å¯¹æ¯” 2010 å¹´è‡³ 2020 å¹´ä¸­å›½å’Œæ—¥æœ¬çš„ GDP å¢é•¿"
   - "2023 å¹´å“ªäº›å›½å®¶çš„äººå‡ GDP æœ€é«˜ï¼Ÿ"

2. **æ—¶åºåˆ†æ**
   - "æ˜¾ç¤ºè¿‡å»åå¹´é‡‘ç –å›½å®¶çš„ GDP è¶‹åŠ¿"
   - "2000 å¹´è‡³ 2020 å¹´å°åº¦çš„äººå£å¢é•¿ç‡æ˜¯å¤šå°‘ï¼Ÿ"

3. **ç»Ÿè®¡æŸ¥è¯¢**
   - "è®¡ç®—æ¬§æ´²å›½å®¶çš„å¹³å‡ GDP å¢é•¿ç‡"
   - "æ‰¾å‡º 2022 å¹´äººå‡ GDP è¶…è¿‡ 50,000 ç¾å…ƒçš„å›½å®¶"

4. **å¤æ‚å¤šå˜é‡åˆ†æ**
   - "äºšæ´²å›½å®¶çš„äººå£ä¸ GDP ä¹‹é—´æœ‰ä»€ä¹ˆç›¸å…³æ€§ï¼Ÿ"
   - "åˆ—å‡ºè¿ç»­ 3 å¹´äººå‡ GDP å¢é•¿è¶…è¿‡ 5% çš„å›½å®¶"


## ç»“è®º

è¿™ä¸ª GDP è¶‹åŠ¿çœ‹æ¿ä»£è¡¨äº†ç»æµæ•°æ®åˆ†æçš„åˆ›æ–°æ–¹æ³•ï¼Œå°†ä¼ ç»Ÿçš„è§†è§‰åŒ–æŠ€æœ¯ä¸å°–ç«¯çš„ AI èƒ½åŠ›ç›¸ç»“åˆã€‚è¯¥é¡¹ç›®å±•ç¤ºäº†ï¼š

- **å…ˆè¿›çš„æ•°æ®é›†æˆ**ï¼šé›†æˆä¸–ç•Œé“¶è¡Œ API ä¸å…¨é¢çš„ç»æµæŒ‡æ ‡
- **è‡ªç„¶è¯­è¨€å¤„ç†**ï¼šAI é©±åŠ¨çš„ SQL ç”Ÿæˆï¼Œå®ç°ä¾¿æ·çš„æ•°æ®æŸ¥è¯¢
- **ä¸“ä¸šçš„è§†è§‰åŒ–**ï¼šé‡‡ç”¨ä¸€è‡´è®¾è®¡çš„äº¤äº’å¼ Plotly å›¾è¡¨
- **åŒè¯­æ”¯æŒ**ï¼šå®Œæ•´çš„è‹±/ä¸­æœ¬åœ°åŒ–
- **ç”Ÿäº§çº§æ¶æ„**ï¼šç¨³å¥çš„é”™è¯¯å¤„ç†ã€ç¼“å­˜å’Œéƒ¨ç½²

æ— è®ºæ‚¨æ˜¯ç»æµå­¦å®¶ã€æ•°æ®ç§‘å­¦å®¶è¿˜æ˜¯æ”¿ç­–åˆ†æå¸ˆï¼Œè¯¥åº”ç”¨ç¨‹åºéƒ½å±•ç¤ºäº†ç°ä»£ AI æŠ€æœ¯å¦‚ä½•é€šè¿‡ç›´è§‚çš„ç•Œé¢å’Œæ™ºèƒ½è‡ªåŠ¨åŒ–ï¼Œä½¿å¤æ‚çš„ç»æµæ•°æ®å˜å¾—æ›´åŠ æ˜“äºè·å–å’Œåˆ©ç”¨ã€‚

---

**æŠ€æœ¯æ ˆ**ï¼šStreamlit, DuckDB, Plotly, ModelScope API, World Bank API

**æ•°æ®æº**ï¼šä¸–ç•Œé“¶è¡Œ (2000-2024, 200+ å›½å®¶, 15,000+ æ•°æ®ç‚¹)

