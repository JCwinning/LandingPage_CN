{
  "hash": "26d0c0861c0c1d40169afeb9d8f19749",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"AI 裁判 (AI Judge)\"\nauthor: \"Tony D\"\ndate: \"2026-01-30\"\ncategories: [AI]\nimage: \"images/images.jpeg\"\nformat:\n  html:\n    code-fold: true\n    code-tools: true\n    code-copy: true\nexecute:\n  warning: false\n---\n\n\n使用三种方法实现 AI 裁判 (AI Judge) 的 AI 工作流过程：**LangGraph**、**LangChain (LCEL)** 和 **n8n**：\n\n-   \n\n    1.  **用户输入**：提出一个问题。\n\n-   \n\n    2.  **模型 A**：生成一个回答。\n\n-   \n\n    3.  **模型 B**：生成一个回答。\n\n-   \n\n    4.  **模型 C**：生成一个回答。\n\n-   \n\n    5.  **裁判 (Judge)**：对比这三个回答，并提供评分（0-100）和评语。\n\n```{mermaid}\ngraph TD\n    Start([Start]) --> ModelA[Model A]\n    Start --> ModelB[Model B]\n    Start --> ModelC[Model C]\n    ModelA --> Judge{AI Judge}\n    ModelB --> Judge\n    ModelC --> Judge\n    Judge --> End([End])\n```\n\n::: panel-tabset\n# LangGraph\n\n## 1. 设置与环境\n\n首先，我们需要导入必要的库并加载 API 密钥。我们确保环境中可以使用 openrouter。\n\n::: {#1c112194 .cell execution_count=1}\n``` {.python .cell-code}\nimport os\nfrom dotenv import load_dotenv\nfrom typing import TypedDict, Annotated\nfrom langgraph.graph import StateGraph, END\n\n# Load environment variables from .env file\nload_dotenv()\n\n# Verify API Key\nif not os.getenv(\"openrouter\"):\n    print(\"WARNING: openrouter not found in environment. Please check your .env file.\")\nelse:\n    print(\"API Key loaded successfully.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAPI Key loaded successfully.\n```\n:::\n:::\n\n\n## 2. 初始化模型客户端\n\n我们将使用标准的 openai Python 客户端，但将其指向 OpenRouter。\n\n::: {#8a9b92de .cell execution_count=2}\n``` {.python .cell-code}\nfrom openai import OpenAI\n\nclient = OpenAI(\n    base_url=\"https://openrouter.ai/api/v1\",\n    api_key=os.getenv(\"openrouter\"),\n)\n\ndef query_model(model_name: str, prompt: str, system_prompt: str = None) -> str:\n    \"\"\"Helper function to query an LLM via OpenRouter.\"\"\"\n    try:\n        messages = []\n        if system_prompt:\n            messages.append({\"role\": \"system\", \"content\": system_prompt})\n        messages.append({\"role\": \"user\", \"content\": prompt})\n        \n        response = client.chat.completions.create(\n          extra_headers={\n                \"HTTP-Referer\": \"https://ai_chatbot.github.io/\",  \n                \"X-Title\": \"AI Judge langgraph\",  # Your app's display name\n            },\n            model=model_name,\n            messages=messages,\n        )\n        return response.choices[0].message.content\n    except Exception as e:\n        return f\"Error calling {model_name}: {e}\"\n```\n:::\n\n\n## 3. 定义状态 (State)\n\n在 LangGraph 中，**状态 (State)** 是在节点之间传递的共享数据结构。在这里，我们的状态跟踪问题、所有回答以及最终的评判结果。\n\n::: {#439d9763 .cell execution_count=3}\n``` {.python .cell-code}\nclass JudgeState(TypedDict):\n    question: str\n    answer_a: str\n    answer_b: str\n    answer_c: str\n    judgment: str\n```\n:::\n\n\n## 4. 定义节点 (Nodes)\n\n我们为图定义了四个关键节点：1. **模型 A 节点**：回答问题。2. **模型 B 节点**：回答同一个问题。3. **模型 C 节点**：回答同一个问题。4. **裁判节点**：在不知道模型名称的情况下，审核问题和所有三个回答。\n\n::: {#a5769499 .cell execution_count=4}\n``` {.python .cell-code}\n# Models\nMODEL_A = \"openai/gpt-oss-20b\"\nMODEL_B =  \"deepseek/deepseek-v3.2\"\nMODEL_C = \"x-ai/grok-4.1-fast\"\nMODEL_JUDGE = \"google/gemini-3-flash-preview\"\n\n\ndef node_model_a(state: JudgeState) -> JudgeState:\n    \"\"\"Query Model A\"\"\"\n    print(f\"--- Calling Model A ---\")\n    system_msg = \"If you do not know the answer then reply I am not sure.\"\n    ans = query_model(MODEL_A, state[\"question\"], system_prompt=system_msg)\n    return {\"answer_a\": ans}\n\n\ndef node_model_b(state: JudgeState) -> JudgeState:\n    \"\"\"Query Model B\"\"\"\n    print(f\"--- Calling Model B ---\")\n    system_msg = \"If you do not know the answer then reply I am not sure.\"\n    ans = query_model(MODEL_B, state[\"question\"], system_prompt=system_msg)\n    return {\"answer_b\": ans}\n\n\ndef node_model_c(state: JudgeState) -> JudgeState:\n    \"\"\"Query Model C\"\"\"\n    print(f\"--- Calling Model C ---\")\n    system_msg = \"If you do not know the answer then reply I am not sure.\"\n    ans = query_model(MODEL_C, state[\"question\"], system_prompt=system_msg)\n    return {\"answer_c\": ans}\n\n\ndef node_judge(state: JudgeState) -> JudgeState:\n    \"\"\"Query Judge Model\"\"\"\n    print(f\"--- Calling Judge ---\")\n\n    prompt = f\"\"\"\n    You are an AI Judge. You will be presented with a question and three candidate answers (Model A, Model B, and Model C).\n    Your task is to judge the quality of the answers without knowing which models produced them.\n    \n    Question: {state['question']}\n    \n    Answer A:\n    {state['answer_a']}\n    \n    Answer B:\n    {state['answer_b']}\n    \n    Answer C:\n    {state['answer_c']}\n    \n    Task:\n    1. Compare the three answers for accuracy, clarity, and completeness.\n    2. format and length of the answers are not important, focus on content quality.\n    3. Provide a short commentary.\n    4. Assign a score from 0 to 100 for Model A, Model B, and Model C.\n    5. Declare the overall winner.\n    \n    Output Format:\n    Commentary: <text>\n    Winner: <Model A, Model B, or Model C>\n    Score A: <number>\n    Score B: <number>\n    Score C: <number>\n    \"\"\"\n\n    judgment = query_model(MODEL_JUDGE, prompt)\n    return {\"judgment\": judgment}\n```\n:::\n\n\n## 5. 构建图 (Graph)\n\n现在我们通过添加节点和定义流（边 Edges）来组装图。模型 A、模型 B 和模型 C 将**独立且并行**运行，然后由裁判进行评判。\n\n::: {#9fd17633 .cell execution_count=5}\n``` {.python .cell-code}\nfrom langgraph.graph import START\n\nworkflow = StateGraph(JudgeState)\n\n# Add nodes\nworkflow.add_node(\"model_a\", node_model_a)\nworkflow.add_node(\"model_b\", node_model_b)\nworkflow.add_node(\"model_c\", node_model_c)\nworkflow.add_node(\"judge\", node_judge)\n\n# Parallel flow: START -> A & B & C -> Judge -> END\nworkflow.add_edge(START, \"model_a\")\nworkflow.add_edge(START, \"model_b\")\nworkflow.add_edge(START, \"model_c\")\nworkflow.add_edge(\"model_a\", \"judge\")\nworkflow.add_edge(\"model_b\", \"judge\")\nworkflow.add_edge(\"model_c\", \"judge\")\nworkflow.add_edge(\"judge\", END)\n\n# Compile the graph\napp = workflow.compile()\n```\n:::\n\n\n## 6. 执行\n\n最后，我们使用一个示例问题运行该工作流。\n\n::: {#b2104e76 .cell execution_count=6}\n``` {.python .cell-code}\ninput_question = \"Will AI take over the world in the next 50 years?\"\n\n# Initialize state\ninitial_state = {\"question\": input_question}\n\n# Run the graph\nresult = app.invoke(initial_state)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n--- Calling Model A ---\n--- Calling Model B ---\n--- Calling Model C ---\n--- Calling Judge ---\n```\n:::\n:::\n\n\n::: {#e6869bcf .cell execution_count=7}\n``` {.python .cell-code}\n# Display Results\nprint(\"\\n\" + \"=\"*40)\n\nprint(f\"QUESTION: {result['question']}\")\nprint(\"=\"*40)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n========================================\nQUESTION: Will AI take over the world in the next 50 years?\n========================================\n```\n:::\n:::\n\n\n### 模型 A\n\n::: {#840e69dc .cell execution_count=8}\n``` {.python .cell-code}\nprint(MODEL_A)\nprint(f\"\\n[Model A ]:\\n{result.get('answer_a', 'No response')}\") \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nopenai/gpt-oss-20b\n\n[Model A ]:\nIt’s a question that gets a lot of speculation, but most experts would agree that an AI “taking over the world” in the sense of a single autonomous entity controlling governments, economies, or everyday life is highly unlikely within the next 50 years. Here’s why:\n\n| Factor | Current reality | 50‑year outlook | Why the scenario is unlikely |\n|--------|-----------------|-----------------|------------------------------|\n| **Technical state of AI** | Narrow AI (deep learning, NLP, etc.) excels at specific tasks but lacks general common‑sense reasoning, self‑reflexive goals, or long‑term planning. | Incremental progress toward more general but still domain‑specific systems (e.g., multimodal, few‑shot learning). | No evidence of a system that can autonomously redesign itself, acquire resources, or out‑maneuver human governance. |\n| **Hardware limits** | Massive GPUs and specialized accelerators enable scaling but also tie performance to cost and energy consumption. | Advances in silicon, photonic processors, and quantum hardware might increase raw speed, yet training and inference for a true “world‑dominating” agent would still require astronomical data and power. | Even exascale computing would be dwarfed by the computational demands of global‑scale autonomous control. |\n| **Data and knowledge** | Models are only as good as the curated data they’re trained on. Open‑world reasoning is a problem—AI can hallucinate or misinterpret new contexts. | Improvements in continual learning, self‑supervised signals, and large knowledge graphs may reduce gaps, but the universe is too vast for any single model to master. | Lack of comprehensive, up‑to‑date, context‑rich data hinders a truly autonomous agent from operating worldwide. |\n| **Safety & governance** | Research on alignment, interpretability, and fail‑safe mechanisms is fast growing; many organizations set up oversight boards and open‑source safety modules. | Regulatory frameworks (e.g., EU AI Act, US federal agencies) will likely enforce risk‑assessment, certification, and transparency for high‑impact systems. | Regulatory, technical, and cultural pushes make it difficult for an unverified AI to “take over” undetected. |\n| **Human control** | Current deployment is tightly coupled to human objectives: APIs, fine‑tuning, and manual oversight. | Even as general‑intelligence benchmarks approach, human‑in‑the‑loop systems will remain standard in critical domains (healthcare, finance, autonomous vehicles). | Most sectors will continue to rely on hybrid human‑AI systems, limiting the chance for complete autonomous governance. |\n| **Economic & political dynamics** | AI innovations are commercial, funded by incumbents, and subject to market incentives. | Policy makers and civil society are increasingly active in shaping AI norms, with a focus on equity, privacy, and security. | The political will to allow a single AI entity to dominate would be resisted by multiple stakeholders. |\n\n### What “taking over” would actually require\n1. **General-purpose intelligence** with self‑directed objectives.  \n2. **Access to physical resources** (energy, infrastructure).  \n3. **Survival incentives** that override human safety constraints.  \n4. **Strategic capabilities** to influence or bypass human institutions.\n\nNone of these exist today, and each is a major research milestone that carries significant technical, ethical, and legal barriers.\n\n### The more realistic future\nIn five decades we are likely to see:\n* **Better generalization** across domains, but still heavily guided by human intent.  \n* **Robust safety protocols**, explainability dashboards, and audit trails.  \n* **Global norms** (e.g., AI safety treaties) that constrain unchecked deployment.  \n* **Distributed AI ecosystems**—many large, specialized systems operating under shared standards, not a single overseer.\n\n### Bottom line\nWhile it’s prudent to treat AI as a powerful tool that must be governed responsibly, the notion that a single AI will “take over the world” in the next 50 years is, given current knowledge and trends, highly improbable. It’s more realistic to focus on managing the societal, economic, and policy impacts of increasingly capable AI systems than on a dystopian domination scenario.\n```\n:::\n:::\n\n\n### 模型 B\n\n::: {#9e6891f4 .cell execution_count=9}\n``` {.python .cell-code}\nprint(MODEL_B)\nprint(f\"\\n[Model B ]:\\n{result.get('answer_b', 'No response')}\")\nprint(\"=\"*40)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ndeepseek/deepseek-v3.2\n\n[Model B ]:\nThat's one of the most debated questions of our time. The short answer is: **It's highly unlikely that AI will \"take over the world\" in a Hollywood-style robot apocalypse within 50 years, but it will almost certainly transform it in profound, disruptive, and potentially dangerous ways.**\n\nHere’s a breakdown of the key perspectives and what \"take over\" could actually mean:\n\n### 1. The \"Takeover\" Scenarios (Why People Worry)\n*   **Loss of Control (Alignment Problem):** The core fear is that we might create a superintelligent AI (far surpassing human intelligence) whose goals are not perfectly aligned with human survival and flourishing. If such an AI were to pursue a poorly specified goal (e.g., \"make paperclips\"), it could treat humans as obstacles or resources.\n*   **Economic and Structural Takeover:** A more plausible near-term \"takeover\" is economic. AI could automate a vast number of jobs, not just manual labor but also creative and cognitive work. This could lead to massive economic displacement, increased inequality, and a shift in power to those who control the AI systems.\n*   **Autonomous Weapons:** The use of AI in warfare (lethal autonomous weapons or \"killer robots\") could lead to new forms of conflict and accidental escalation, effectively letting algorithms make life-and-death decisions.\n*   **Informational and Social Control:** AI is already used for hyper-targeted propaganda, deepfakes, and social manipulation. This could erode democracy, truth, and social cohesion, allowing those in control of the technology to wield immense soft power.\n\n### 2. The Counterarguments (Why a Hostile Takeover is Unlikely)\n*   **Narrow vs. General Intelligence:** Today's AI (including large language models like me) is **narrow AI**—extraordinarily capable at specific tasks but lacking understanding, consciousness, or general-purpose reasoning. Creating Artificial General Intelligence (AGI) is a monumental, unsolved scientific challenge. 50 years is a long time in tech, but there's no guarantee AGI will be achieved.\n*   **Control and Safety Research:** The field of AI alignment and safety is growing rapidly. Many of the world's top AI labs consider controlling superintelligent AI their primary research problem.\n*   **Human Governance:** AI doesn't exist in a vacuum. Laws, regulations, international treaties, and corporate policies will be developed to manage its risks (just as we did for nuclear power, biotechnology, etc.). The outcome will depend heavily on human political and ethical choices.\n\n### 3. The More Probable Reality (Next 50 Years)\nThe next five decades will likely be defined not by a single hostile AI, but by:\n*   **Ubiquitous Integration:** AI will become like electricity—an invisible, essential utility powering everything from healthcare (personalized medicine) and science (drug discovery, climate modeling) to entertainment and transportation.\n*   **The Partnership Model:** The most productive path is **human-AI collaboration**. AI will augment human capabilities, helping us solve complex problems like disease and climate change, while humans provide oversight, creativity, and ethical judgment.\n*   **Major Societal Challenges:** The biggest threats won't be sentient robots, but:\n    *   **Job Disruption:** We may need to radically rethink concepts like work, income, and purpose.\n    *   **Bias and Fairness:** AI systems can perpetuate and amplify societal biases.\n    *   **Concentration of Power:** The risk of a few corporations or governments controlling world-leading AI.\n    *   **Existential Risk from Misuse:** Even without malice, advanced AI could be catastrophically misused by humans (e.g., in engineered pandemics or cyber warfare).\n\n**Conclusion:**\nInstead of a **\"takeover,\"** think of a **\"handover.\"** We are increasingly handing over decisions—from what news we see to medical diagnoses to financial trades—to AI systems. The critical question for the next 50 years is not *\"Will AI become our master?\"* but ***\"How can we build and govern AI so that it remains a powerful tool for the benefit of all humanity, and how do we adapt our societies to the immense changes it will bring?\"***\n\nThe future isn't pre-written. It will be shaped by the research, policies, and ethical frameworks we develop **today.**\n========================================\n```\n:::\n:::\n\n\n### 模型 C\n\n::: {#f2742286 .cell execution_count=10}\n``` {.python .cell-code}\nprint(MODEL_C)\nprint(f\"\\n[Model C ]:\\n{result.get('answer_c', 'No response')}\")\nprint(\"=\"*40)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx-ai/grok-4.1-fast\n\n[Model C ]:\nI am not sure.\n========================================\n```\n:::\n:::\n\n\n### 裁判模型 (Model JUDGE)\n\n::: {#fd136850 .cell execution_count=11}\n``` {.python .cell-code}\nprint(\"\\n>>> JUDGE'S VERDICT <<<\")\nprint(\"MODEL_A:\")\nprint(MODEL_A)\nprint(\"MODEL_B:\")\nprint(MODEL_B)\nprint(\"MODEL_C:\")\nprint(MODEL_C)\nprint(\"MODEL_JUDGE:\")\nprint(MODEL_JUDGE)\nprint(\"=====\")\nprint(result[\"judgment\"])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n>>> JUDGE'S VERDICT <<<\nMODEL_A:\nopenai/gpt-oss-20b\nMODEL_B:\ndeepseek/deepseek-v3.2\nMODEL_C:\nx-ai/grok-4.1-fast\nMODEL_JUDGE:\ngoogle/gemini-3-flash-preview\n=====\nCommentary: Model A and Model B both provide excellent, high-quality responses to a complex, speculative question. Model A uses a highly structured tabular format to break down the technical, hardware, and regulatory hurdles, providing a very grounded and logical assessment of why a total takeover is unlikely. Model B offers a slightly more nuanced discussion on the different definitions of a \"takeover\" (economic, informational, vs. Hollywood-style), which adds a layer of depth regarding the actual risks humanity faces. Both correctly identify the distinction between Narrow AI and AGI and discuss the importance of the alignment problem. Model C is unhelpful and fails to engage with the prompt. Model A is slightly more impressive due to its systematic breakdown of current vs. future states across multiple dimensions.\n\nWinner: Model A\n\nScore A: 95\nScore B: 92\nScore C: 5\n```\n:::\n:::\n\n\n# LangChain\n\n## 1. 设置与环境\n\n首先，我们需要导入必要的库并加载 API 密钥。我们确保环境中可以使用 openrouter。我们将使用 `langchain-openai` 与 OpenRouter 进行交互。\n\n::: {#d5820d7a .cell execution_count=12}\n``` {.python .cell-code}\nimport os\nfrom dotenv import load_dotenv\nfrom langchain_openai import ChatOpenAI\nfrom langchain_core.prompts import ChatPromptTemplate\nfrom langchain_core.runnables import RunnableParallel, RunnablePassthrough\nfrom langchain_core.output_parsers import StrOutputParser\n\n# Load environment variables from .env file\nload_dotenv()\n\n# Verify API Key\nif not os.getenv(\"openrouter\"):\n    print(\"WARNING: openrouter not found in environment. Please check your .env file.\")\nelse:\n    print(\"API Key loaded successfully.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAPI Key loaded successfully.\n```\n:::\n:::\n\n\n## 2. 初始化模型\n\n我们将初始化指向 OpenRouter 的三个模型实例。\n\n::: {#f6ad7234 .cell execution_count=13}\n``` {.python .cell-code}\n# Models\nMODEL_A_NAME = \"openai/gpt-oss-20b\"\nMODEL_B_NAME = \"deepseek/deepseek-v3.2\"\nMODEL_C_NAME = \"x-ai/grok-4.1-fast\"\nMODEL_JUDGE_NAME = \"google/gemini-3-flash-preview\"\n\ndef get_model(model_name: str):\n    return ChatOpenAI(\n        model=model_name,\n        api_key=os.getenv(\"openrouter\"),\n        base_url=\"https://openrouter.ai/api/v1\",\n        default_headers={\n            \"HTTP-Referer\": \"https://ai_chatbot.github.io/\",\n            \"X-Title\": \"AI Judge LangChain\",\n        }\n    )\n\nmodel_a = get_model(MODEL_A_NAME)\nmodel_b = get_model(MODEL_B_NAME)\nmodel_c = get_model(MODEL_C_NAME)\nmodel_judge = get_model(MODEL_JUDGE_NAME)\n```\n:::\n\n\n## 3. 定义链 (Chains) 与工作流\n\n使用 LangChain 表达式语言 (LCEL)，我们可以轻松定义并行执行和顺序步骤。\n\n::: {#f71e00b7 .cell execution_count=14}\n``` {.python .cell-code}\n# Step 1: Query models in parallel\n# We use RunnableParallel to run model_a, model_b, and model_c at the same time.\nsystem_prompt = \"If you do not know the answer then reply I am not sure.\"\nprompt_template = ChatPromptTemplate.from_messages([\n    (\"system\", system_prompt),\n    (\"user\", \"{question}\")\n])\n\nparallel_responses = RunnableParallel(\n    answer_a=(prompt_template | model_a | StrOutputParser()),\n    answer_b=(prompt_template | model_b | StrOutputParser()),\n    answer_c=(prompt_template | model_c | StrOutputParser()),\n    question=RunnablePassthrough()\n)\n\n# Step 2: Define the Judge Prompt\njudge_prompt = ChatPromptTemplate.from_template(\"\"\"\n    You are an AI Judge. You will be presented with a question and three candidate answers (Model A, Model B, and Model C).\n    Your task is to judge the quality of the answers.\n    \n    Question: {question}\n    \n    Answer A:\n    {answer_a}\n    \n    Answer B:\n    {answer_b}\n    \n    Answer C:\n    {answer_c}\n    \n    Task:\n    1. Compare the three answers for accuracy, clarity, and completeness.\n    2. format and length of the answers are not important, focus on content quality.\n    3. Provide a short commentary.\n    4. Assign a score from 0 to 100 for Model A, Model B, and Model C.\n    5. Declare the overall winner.\n    \n    Output Format:\n    Commentary: <text>\n    Winner: <Model A or Model B or Model C>\n    Score A: <number>\n    Score B: <number>\n    Score C: <number>\n\"\"\")\n\n# Step 3: Combine everything into a full chain\n# The output of parallel_responses is a dict, which matches the input expected by judge_prompt\nfull_chain = parallel_responses | {\n    \"judgment\": judge_prompt | model_judge | StrOutputParser(),\n    \"answer_a\": lambda x: x[\"answer_a\"],\n    \"answer_b\": lambda x: x[\"answer_b\"],\n    \"answer_c\": lambda x: x[\"answer_c\"],\n    \"question\": lambda x: x[\"question\"]\n}\n```\n:::\n\n\n## 4. 执行\n\n最后，我们使用一个示例问题运行该链。\n\n::: {#a0f42c16 .cell execution_count=15}\n``` {.python .cell-code}\ninput_question = \"What is the AI advantage of using transformer architectures over traditional RNNs in natural language processing tasks?\"\n\nprint(f\"--- Running Workflow for Question: {input_question} ---\")\n\n# Execute the chain\nresult = full_chain.invoke({\"question\": input_question})\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n--- Running Workflow for Question: What is the AI advantage of using transformer architectures over traditional RNNs in natural language processing tasks? ---\n```\n:::\n:::\n\n\n## 5. 显示结果\n\n::: {#ed5b3613 .cell execution_count=16}\n``` {.python .cell-code}\nprint(\"\\n\" + \"=\"*40)\nprint(f\"QUESTION: {result['question']}\")\nprint(\"=\"*40)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n========================================\nQUESTION: {'question': 'What is the AI advantage of using transformer architectures over traditional RNNs in natural language processing tasks?'}\n========================================\n```\n:::\n:::\n\n\n### 模型 A\n\n::: {#26eab7cf .cell execution_count=17}\n``` {.python .cell-code}\nprint(f\"MODEL: {MODEL_A_NAME}\")\nprint(f\"\\n[Model A]:\\n{result.get('answer_a', 'No response')}\") \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMODEL: openai/gpt-oss-20b\n\n[Model A]:\n**Transformers versus traditional RNNs**  \nIn natural‑language processing (NLP) the shift from recurrent neural networks (RNNs) and their gated cousins (LSTMs/GRUs) to transformer‑style architectures has become foundational.  The key AI advantages of transformers are rooted in the way they **represent, process, and learn from text**:\n\n| Feature | How Transformers do it | Why it matters over RNNs |\n|---------|------------------------|--------------------------|\n| **Parallelization** | Self‑attention applies to all tokens in a sequence *simultaneously* (batchwise). | RNNs process tokens one after another; this sequential bottleneck limits GPU utilisation and slows both training and inference. |\n| **Capturing long‑range dependencies** | Each token attends to every other token – weighting nearby and far‑away words equally. | RNNs suffer from vanishing/ exploding gradients and struggle to propagate signals over long distances; transformers break this barrier naturally. |\n| **Memory‑friendly gradients** | Layer‑norm, residuals, and attention gradients flow easily, avoiding the need for careful gating mechanisms. | RNNs require gating (LSTM/GRU) to mitigate gradients, yet tuning them is delicate, especially with long sequences. |\n| **Scalable pre‑training & transfer learning** | Layer‑wise transformer blocks can be stacked to huge depths; large‑scale unsupervised architectures such as BERT, GPT, T5 can be fine‑tuned for downstream tasks. | RNN‑based models generally have not reached the same scale or generic transferability. |\n| **Interpretability of attention** | Attention weights provide a view of what the model deems important as it processes each token. | RNNs do not give an explicit, interpretable alignment between inputs and outputs. |\n| **Better handling of varied sequence length** | Position encodings (learned or sinusoidal) give absolute context, enabling transformers to process very short or very long sentences without structural alterations. | RNNs need separate architectures for bidirectional or unidirectional contexts; long sequences make training unstable. |\n| **Efficient inference in practice** | Beam‑search decoding or caching in transformers (e.g. for GPT) can reuse past key/value matrices across time steps. | RNNs recompute hidden states at each step; caching is non‑trivial. |\n| **Architectural simplicity** | Transformers consist mainly of linear layers, attention heads, and feed‑forward networks; no recurrent loops. | Less algorithmic complexity and fewer hyper‑parameters to tweak for long‑term dependencies. |\n\n### Concrete results\n\n| NLP task | Transformer state‑of‑the‑art | RNN‑based performance (historical) |\n|---------|-----------------------------|-----------------------------------|\n| Machine translation (En→De) | 0.93 BLEU (mBART, T5) | 0.75 BLEU (LSTM + attention) |\n| Question answering (SQuAD2.0) | 90 % Exact Match | 70 % |\n| Language modelling (perplexity on WikiText‑103) | 35 (GPT‑2) | ≈ 70 (LSTM) |\n\nThese figures simply illustrate how transformative the architecture is on a wide spectrum of tasks.\n\n---\n\n## Bottom line\n\n**Transformers provide a fundamentally different, highly parallel way to capture arbitrary global context with stable learning dynamics.**  This leads to superior performance across most NLP tasks, faster training and inference, and a versatile framework for large‑scale pre‑training that RNNs cannot match.\n```\n:::\n:::\n\n\n### 模型 B\n\n::: {#5d92ca91 .cell execution_count=18}\n``` {.python .cell-code}\nprint(f\"MODEL: {MODEL_B_NAME}\")\nprint(f\"\\n[Model B]:\\n{result.get('answer_b', 'No response')}\")\nprint(\"=\"*40)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMODEL: deepseek/deepseek-v3.2\n\n[Model B]:\nOf course. Here’s a clear breakdown of the key AI advantages of Transformer architectures over traditional RNNs (like LSTMs and GRUs) in NLP tasks.\n\nThe core difference is that **Transformers process all words in a sequence simultaneously** and use a **self-attention mechanism** to understand contextual relationships, whereas RNNs process words sequentially and struggle with long-range dependencies.\n\n### Key Advantages of Transformers:\n\n1.  **Parallelization & Speed:** RNNs are inherently sequential—they must compute step-by-step, making them slow on modern hardware (GPUs/TPUs). Transformers process all tokens in a sequence in parallel, leading to vastly faster training times.\n\n2.  **Long-Range Dependency Handling:** RNNs suffer from the \"vanishing gradient\" problem, making it hard to learn relationships between distant words. Transformers' self-attention mechanism can directly connect any two words in the sequence, regardless of distance, with a constant number of operations. This is crucial for tasks like document understanding or long-form text generation.\n\n3.  **Superior Contextual Understanding via Self-Attention:** Self-attention allows each word to directly attend to all other words in the sequence, weighing their importance. This creates richer, more nuanced contextual embeddings than RNNs, which compress past information into a single hidden state.\n\n4.  **Scalability with Model Size:** Because of parallelization, Transformers can be scaled up dramatically (more layers, larger hidden dimensions) to create massive models (like GPT and BERT). This scaling has been empirically shown to lead to consistently better performance. RNNs become prohibitively slow and unstable as they grow deeper.\n\n5.  **Effectiveness on Modern Hardware:** Transformers are dominated by matrix multiplications, which are perfectly suited for acceleration on GPUs/TPUs. RNNs' sequential nature underutilizes this hardware.\n\n### Where Traditional RNNs Might Still Have a Niche:\n- **Streaming/Online Tasks:** For tasks where input arrives in a continuous, real-time stream (e.g., real-time speech processing), RNNs can process data incrementally without a fixed sequence length, while standard Transformers require a pre-defined context window.\n- **Extremely Low-Resource Environments:** Very small RNNs can be more efficient for simple tasks where massive contextual understanding isn't needed.\n\n**In summary, Transformers replaced RNNs as the dominant architecture in NLP because their ability to process information in parallel and model long-range dependencies directly led to **faster training, more powerful models, and significantly better performance** across almost all benchmark tasks.** The rise of large language models (LLMs) is fundamentally a result of the Transformer's scalable architecture.\n========================================\n```\n:::\n:::\n\n\n### 模型 C\n\n::: {#e3041ff2 .cell execution_count=19}\n``` {.python .cell-code}\nprint(f\"MODEL: {MODEL_C_NAME}\")\nprint(f\"\\n[Model C]:\\n{result.get('answer_c', 'No response')}\")\nprint(\"=\"*40)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMODEL: x-ai/grok-4.1-fast\n\n[Model C]:\n**Key AI advantages of Transformer architectures over traditional RNNs (e.g., LSTMs or GRUs) in NLP tasks:**\n\n- **Parallel Processing**: Transformers use self-attention to process entire sequences (all tokens) simultaneously, enabling massive parallelization on GPUs/TPUs. RNNs process tokens sequentially (one timestep at a time), leading to slower training and inference, especially for long sequences.\n\n- **Superior Handling of Long-Range Dependencies**: Self-attention mechanisms directly compute relationships between any pair of tokens, regardless of distance. RNNs struggle with this due to sequential information flow, causing \"vanishing gradients\" and forgetting distant context (even in improved variants like LSTMs).\n\n- **Mitigation of Gradient Issues**: Transformers avoid recurrent connections, eliminating vanishing/exploding gradient problems during backpropagation through time (BPTT) in RNNs, allowing stable training on much longer sequences.\n\n- **Scalability and Efficiency**: Transformers scale better with model size, data volume, and compute (e.g., via larger batch sizes and deeper layers). This has led to breakthroughs like BERT, GPT, and T5, outperforming RNNs on tasks like machine translation, summarization, and question answering.\n\n- **Flexibility**: Positional encodings allow Transformers to handle variable-length inputs without state management, unlike RNNs which maintain hidden states.\n\n**Empirical Evidence**: On benchmarks like GLUE or SQuAD, Transformers achieve 10-30%+ accuracy gains over RNN baselines, with training times reduced from days/weeks to hours for large datasets.\n\nIn summary, Transformers revolutionized NLP by trading recurrence for attention, enabling faster, more effective models for modern-scale data.\n========================================\n```\n:::\n:::\n\n\n### AI 裁判结论\n\n::: {#84e88517 .cell execution_count=20}\n``` {.python .cell-code}\nprint(\"\\n>>> JUDGE'S VERDICT <<<\")\nprint(f\"MODEL_A: {MODEL_A_NAME}\")\nprint(f\"MODEL_B: {MODEL_B_NAME}\")\nprint(f\"MODEL_C: {MODEL_C_NAME}\")\nprint(f\"JUDGE:   {MODEL_JUDGE_NAME}\")\nprint(\"=====\")\nprint(result['judgment'])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n>>> JUDGE'S VERDICT <<<\nMODEL_A: openai/gpt-oss-20b\nMODEL_B: deepseek/deepseek-v3.2\nMODEL_C: x-ai/grok-4.1-fast\nJUDGE:   google/gemini-3-flash-preview\n=====\nCommentary: Model A provides the most comprehensive and high-quality response. It utilizes a tabular format that makes it easy to compare specific features and their impacts. It also includes concrete (though illustrative) performance metrics and addresses more nuanced advantages like interpretability and inference caching. Model B is also excellent, adding a thoughtful section on where RNNs might still be useful, providing a balanced perspective. Model C is a solid, standard technical summary but lacks the extra depth and formatting polish of the other two.\n\nWinner: Model A\n\nScore A: 96\nScore B: 90\nScore C: 82\n```\n:::\n:::\n\n\n# n8n\n\n\n![](images/clipboard-1254380001.png)\n\n\n## JSON 文件\n\n::: {#4a7745cf .cell execution_count=21}\n``` {.python .cell-code}\n{\n  \"name\": \"AI Judge Workflow\",\n  \"nodes\": [\n    {\n      \"parameters\": {\n        \"assignments\": {\n          \"assignments\": [\n            {\n              \"id\": \"question-field\",\n              \"name\": \"question\",\n              \"value\": \"what is AI?\",\n              \"type\": \"string\"\n            }\n          ]\n        },\n        \"options\": {}\n      },\n      \"id\": \"30f77dc6-8e05-4ddb-8902-1638b09abe7b\",\n      \"name\": \"Set Question1\",\n      \"type\": \"n8n-nodes-base.set\",\n      \"typeVersion\": 3.4,\n      \"position\": [\n        -688,\n        16\n      ]\n    },\n    {\n      \"parameters\": {\n        \"method\": \"POST\",\n        \"url\": \"https://openrouter.ai/api/v1/chat/completions\",\n        \"authentication\": \"genericCredentialType\",\n        \"genericAuthType\": \"httpBearerAuth\",\n        \"sendHeaders\": true,\n        \"headerParameters\": {\n          \"parameters\": [\n            {\n              \"name\": \"Content-Type\",\n              \"value\": \"application/json\"\n            }\n          ]\n        },\n        \"sendBody\": true,\n        \"specifyBody\": \"json\",\n        \"jsonBody\": \"={{ JSON.stringify({\\n  \\\"model\\\": \\\"openai/gpt-oss-120b:free\\\",\\n  \\\"messages\\\": [\\n    {\\\"role\\\": \\\"system\\\", \\\"content\\\": \\\"If you do not know the answer then reply I am not sure.\\\"},\\n    {\\\"role\\\": \\\"user\\\", \\\"content\\\": $json.question}\\n  ]\\n}) }}\",\n        \"options\": {}\n      },\n      \"id\": \"104becd7-9b3d-4297-b4ab-47b1df1abd71\",\n      \"name\": \"Model A\",\n      \"type\": \"n8n-nodes-base.httpRequest\",\n      \"typeVersion\": 4.2,\n      \"position\": [\n        -480,\n        -160\n      ],\n      \"credentials\": {\n        \"httpHeaderAuth\": {\n          \"id\": \"Lf6835mjFnfNIqw6\",\n          \"name\": \"Header Auth account 2\"\n        },\n        \"httpBearerAuth\": {\n          \"id\": \"KFNalQ91U3mlnQks\",\n          \"name\": \"Bearer Auth account\"\n        }\n      }\n    },\n    {\n      \"parameters\": {\n        \"method\": \"POST\",\n        \"url\": \"https://openrouter.ai/api/v1/chat/completions\",\n        \"authentication\": \"genericCredentialType\",\n        \"genericAuthType\": \"httpBearerAuth\",\n        \"sendHeaders\": true,\n        \"headerParameters\": {\n          \"parameters\": [\n            {\n              \"name\": \"Content-Type\",\n              \"value\": \"application/json\"\n            }\n          ]\n        },\n        \"sendBody\": true,\n        \"specifyBody\": \"json\",\n        \"jsonBody\": \"={{ JSON.stringify({\\n  \\\"model\\\": \\\"openai/gpt-oss-20b\\\",\\n  \\\"messages\\\": [\\n    {\\\"role\\\": \\\"system\\\", \\\"content\\\": \\\"If you do not know the answer then reply I am not sure.\\\"},\\n    {\\\"role\\\": \\\"user\\\", \\\"content\\\": $json.question}\\n  ]\\n}) }}\",\n        \"options\": {}\n      },\n      \"id\": \"2c4d3906-bcd3-4fc6-b983-4e9e494e476f\",\n      \"name\": \"Model B\",\n      \"type\": \"n8n-nodes-base.httpRequest\",\n      \"typeVersion\": 4.2,\n      \"position\": [\n        -480,\n        16\n      ],\n      \"credentials\": {\n        \"httpHeaderAuth\": {\n          \"id\": \"Lf6835mjFnfNIqw6\",\n          \"name\": \"Header Auth account 2\"\n        },\n        \"httpBearerAuth\": {\n          \"id\": \"KFNalQ91U3mlnQks\",\n          \"name\": \"Bearer Auth account\"\n        }\n      }\n    },\n    {\n      \"parameters\": {\n        \"method\": \"POST\",\n        \"url\": \"https://openrouter.ai/api/v1/chat/completions\",\n        \"authentication\": \"genericCredentialType\",\n        \"genericAuthType\": \"httpBearerAuth\",\n        \"sendHeaders\": true,\n        \"headerParameters\": {\n          \"parameters\": [\n            {\n              \"name\": \"Content-Type\",\n              \"value\": \"application/json\"\n            }\n          ]\n        },\n        \"sendBody\": true,\n        \"specifyBody\": \"json\",\n        \"jsonBody\": \"={{ JSON.stringify({\\n  \\\"model\\\": \\\"arcee-ai/trinity-large-preview:free\\\",\\n  \\\"messages\\\": [\\n    {\\\"role\\\": \\\"system\\\", \\\"content\\\": \\\"If you do not know the answer then reply I am not sure.\\\"},\\n    {\\\"role\\\": \\\"user\\\", \\\"content\\\": $json.question}\\n  ]\\n}) }}\",\n        \"options\": {}\n      },\n      \"id\": \"3f5e4a8b-c9d2-4ab7-a123-456789012345\",\n      \"name\": \"Model C\",\n      \"type\": \"n8n-nodes-base.httpRequest\",\n      \"typeVersion\": 4.2,\n      \"position\": [\n        -480,\n        192\n      ],\n      \"credentials\": {\n        \"httpHeaderAuth\": {\n          \"id\": \"Lf6835mjFnfNIqw6\",\n          \"name\": \"Header Auth account 2\"\n        },\n        \"httpBearerAuth\": {\n          \"id\": \"KFNalQ91U3mlnQks\",\n          \"name\": \"Bearer Auth account\"\n        }\n      }\n    },\n    {\n      \"parameters\": {\n        \"assignments\": {\n          \"assignments\": [\n            {\n              \"id\": \"map-a\",\n              \"name\": \"answer_a\",\n              \"value\": \"={{ $json.choices[0].message.content }}\",\n              \"type\": \"string\"\n            }\n          ]\n        },\n        \"options\": {}\n      },\n      \"id\": \"bb423cd5-28ff-47e5-8925-492143d26228\",\n      \"name\": \"Set Answer A1\",\n      \"type\": \"n8n-nodes-base.set\",\n      \"typeVersion\": 3.4,\n      \"position\": [\n        -256,\n        -160\n      ]\n    },\n    {\n      \"parameters\": {\n        \"assignments\": {\n          \"assignments\": [\n            {\n              \"id\": \"map-b\",\n              \"name\": \"answer_b\",\n              \"value\": \"={{ $json.choices[0].message.content }}\",\n              \"type\": \"string\"\n            }\n          ]\n        },\n        \"options\": {}\n      },\n      \"id\": \"591d8be5-132d-45a2-a69d-455467da46e5\",\n      \"name\": \"Set Answer B1\",\n      \"type\": \"n8n-nodes-base.set\",\n      \"typeVersion\": 3.4,\n      \"position\": [\n        -256,\n        16\n      ]\n    },\n    {\n      \"parameters\": {\n        \"assignments\": {\n          \"assignments\": [\n            {\n              \"id\": \"map-c\",\n              \"name\": \"answer_c\",\n              \"value\": \"={{ $json.choices[0].message.content }}\",\n              \"type\": \"string\"\n            }\n          ]\n        },\n        \"options\": {}\n      },\n      \"id\": \"7a8b9c0d-1e2f-4a3b-8c4d-5e6f7a8b9c0d\",\n      \"name\": \"Set Answer C1\",\n      \"type\": \"n8n-nodes-base.set\",\n      \"typeVersion\": 3.4,\n      \"position\": [\n        -256,\n        192\n      ]\n    },\n    {\n      \"parameters\": {\n        \"mode\": \"combine\",\n        \"combineBy\": \"combineAll\",\n        \"options\": {}\n      },\n      \"id\": \"merge-ab-node-id\",\n      \"name\": \"Merge AB\",\n      \"type\": \"n8n-nodes-base.merge\",\n      \"typeVersion\": 3,\n      \"position\": [\n        -32,\n        -72\n      ]\n    },\n    {\n      \"parameters\": {\n        \"mode\": \"combine\",\n        \"combineBy\": \"combineAll\",\n        \"options\": {}\n      },\n      \"id\": \"2c89b328-cac3-4322-bcf6-b8ae5f9c0af2\",\n      \"name\": \"Merge Answers1\",\n      \"type\": \"n8n-nodes-base.merge\",\n      \"typeVersion\": 3,\n      \"position\": [\n        160,\n        16\n      ]\n    },\n    {\n      \"parameters\": {\n        \"method\": \"POST\",\n        \"url\": \"https://openrouter.ai/api/v1/chat/completions\",\n        \"authentication\": \"genericCredentialType\",\n        \"genericAuthType\": \"httpBearerAuth\",\n        \"sendHeaders\": true,\n        \"headerParameters\": {\n          \"parameters\": [\n            {\n              \"name\": \"Content-Type\",\n              \"value\": \"application/json\"\n            }\n          ]\n        },\n        \"sendBody\": true,\n        \"specifyBody\": \"json\",\n        \"jsonBody\": \"={{ JSON.stringify({\\n  \\\"model\\\": \\\"google/gemini-3-flash-preview\\\",\\n  \\\"messages\\\": [\\n    {\\n      \\\"role\\\": \\\"user\\\",\\n      \\\"content\\\": \\\"You are an AI Judge. You will be presented with a question and three candidate answers (Model A, Model B, and Model C).\\\\nYour task is to judge the quality of the answers.\\\\n\\\\nQuestion: \\\" + $(\\\"Set Question1\\\").first().json.question + \\\"\\\\n\\\\nAnswer A:\\\\n\\\" + ($json.answer_a || \\\"No answer provided\\\") + \\\"\\\\n\\\\nAnswer B:\\\\n\\\" + ($json.answer_b || \\\"No answer provided\\\") + \\\"\\\\n\\\\nAnswer C:\\\\n\\\" + ($json.answer_c || \\\"No answer provided\\\") + \\\"\\\\n\\\\nTask:\\\\n1. Compare the three answers for accuracy, clarity, and completeness.\\\\n2. format and length of the answers are not important, focus on content quality.\\\\n3. Provide a short commentary.\\\\n4. Assign a score from 0 to 100 for Model A, Model B, and Model C.\\\\n5. Declare the overall winner.\\\\n\\\\nOutput Format:\\\\nCommentary: <text>\\\\nWinner: <Model A or Model B or Model C>\\\\nScore A: <number>\\\\nScore B: <number>\\\\nScore C: <number>\\\"\\n    }\\n  ]\\n}) }}\",\n        \"options\": {}\n      },\n      \"id\": \"1d6171c9-4800-4f25-97a0-c029053e1ddc\",\n      \"name\": \"AI Judge1\",\n      \"type\": \"n8n-nodes-base.httpRequest\",\n      \"typeVersion\": 4.2,\n      \"position\": [\n        368,\n        16\n      ],\n      \"credentials\": {\n        \"httpHeaderAuth\": {\n          \"id\": \"Lf6835mjFnfNIqw6\",\n          \"name\": \"Header Auth account 2\"\n        },\n        \"httpBearerAuth\": {\n          \"id\": \"KFNalQ91U3mlnQks\",\n          \"name\": \"Bearer Auth account\"\n        }\n      }\n    },\n    {\n      \"parameters\": {\n        \"assignments\": {\n          \"assignments\": [\n            {\n              \"id\": \"final-result\",\n              \"name\": \"verdict\",\n              \"value\": \"={{ $json.choices[0].message.content }}\",\n              \"type\": \"string\"\n            },\n            {\n              \"id\": \"model-a-ans\",\n              \"name\": \"answer_a\",\n              \"value\": \"={{ $node[\\\"Merge Answers1\\\"].json.answer_a }}\",\n              \"type\": \"string\"\n            },\n            {\n              \"id\": \"model-b-ans\",\n              \"name\": \"answer_b\",\n              \"value\": \"={{ $node[\\\"Merge Answers1\\\"].json.answer_b }}\",\n              \"type\": \"string\"\n            },\n            {\n              \"id\": \"model-c-ans\",\n              \"name\": \"answer_c\",\n              \"value\": \"={{ $node[\\\"Merge Answers1\\\"].json.answer_c }}\",\n              \"type\": \"string\"\n            }\n          ]\n        },\n        \"options\": {}\n      },\n      \"id\": \"eae7f7bf-07fc-4250-b628-1a422cfbbe12\",\n      \"name\": \"Final Output1\",\n      \"type\": \"n8n-nodes-base.set\",\n      \"typeVersion\": 3.4,\n      \"position\": [\n        576,\n        16\n      ]\n    }\n  ],\n  \"pinData\": {},\n  \"connections\": {\n    \"Set Question1\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Model A\",\n            \"type\": \"main\",\n            \"index\": 0\n          },\n          {\n            \"node\": \"Model B\",\n            \"type\": \"main\",\n            \"index\": 0\n          },\n          {\n            \"node\": \"Model C\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"Model A\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Set Answer A1\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"Model B\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Set Answer B1\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"Model C\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Set Answer C1\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"Set Answer A1\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Merge AB\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"Set Answer B1\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Merge AB\",\n            \"type\": \"main\",\n            \"index\": 1\n          }\n        ]\n      ]\n    },\n    \"Set Answer C1\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Merge Answers1\",\n            \"type\": \"main\",\n            \"index\": 1\n          }\n        ]\n      ]\n    },\n    \"Merge AB\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Merge Answers1\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"Merge Answers1\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"AI Judge1\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"AI Judge1\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Final Output1\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    }\n  },\n  \"active\": false,\n  \"settings\": {\n    \"executionOrder\": \"v1\",\n    \"availableInMCP\": false\n  },\n  \"versionId\": \"ac74f20b-72a9-49a6-8200-fd08707946ec\",\n  \"meta\": {\n    \"instanceId\": \"2f42f1cdfcab2c6a7bbd5cec68912930ccc0107686e3a7211ddcc09504c524d9\"\n  },\n  \"id\": \"8a_wyeYhdVZSr42SS5Z1K\",\n  \"tags\": []\n}\n```\n:::\n\n\n:::\n\n",
    "supporting": [
      "index_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}